<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WCSim: basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WCSim
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbasic__json-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace for Niels Lohmann  
 <a href="classbasic__json.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="json_8hpp_source.html">json.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classbasic__json__inherit__graph.png" border="0" usemap="#basic__json_3_01_object_type_00_01_array_type_00_01_string_type_00_01_boolean_type_00_01_number_integer_type_00_01_number_unsigned_type_00_01_number_float_type_00_01_allocator_type_00_01_j_s_o_n_serializer_00_01_binary_type_00_01_custom_base_class_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="basic__json_3_01_object_type_00_01_array_type_00_01_string_type_00_01_boolean_type_00_01_number_integer_type_00_01_number_unsigned_type_00_01_number_float_type_00_01_allocator_type_00_01_j_s_o_n_serializer_00_01_binary_type_00_01_custom_base_class_01_4_inherit__map" id="basic__json_3_01_object_type_00_01_array_type_00_01_string_type_00_01_boolean_type_00_01_number_integer_type_00_01_number_unsigned_type_00_01_number_float_type_00_01_allocator_type_00_01_j_s_o_n_serializer_00_01_binary_type_00_01_custom_base_class_01_4_inherit__map">
</map>
</div>
<div class="dynheader">
Collaboration diagram for basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classbasic__json__coll__graph.png" border="0" usemap="#basic__json_3_01_object_type_00_01_array_type_00_01_string_type_00_01_boolean_type_00_01_number_integer_type_00_01_number_unsigned_type_00_01_number_float_type_00_01_allocator_type_00_01_j_s_o_n_serializer_00_01_binary_type_00_01_custom_base_class_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="basic__json_3_01_object_type_00_01_array_type_00_01_string_type_00_01_boolean_type_00_01_number_integer_type_00_01_number_unsigned_type_00_01_number_float_type_00_01_allocator_type_00_01_j_s_o_n_serializer_00_01_binary_type_00_01_custom_base_class_01_4_coll__map" id="basic__json_3_01_object_type_00_01_array_type_00_01_string_type_00_01_boolean_type_00_01_number_integer_type_00_01_number_unsigned_type_00_01_number_float_type_00_01_allocator_type_00_01_j_s_o_n_serializer_00_01_binary_type_00_01_custom_base_class_01_4_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a966e900415e66f3ab60f7b5ef52fd63b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a966e900415e66f3ab60f7b5ef52fd63b">value_t</a> = <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a></td></tr>
<tr class="separator:a966e900415e66f3ab60f7b5ef52fd63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe66720a34c11920f359394a4430a16e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> = ::nlohmann::json_pointer&lt; StringType &gt;</td></tr>
<tr class="memdesc:afe66720a34c11920f359394a4430a16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON Pointer, see nlohmann::json_pointer.  <a href="#afe66720a34c11920f359394a4430a16e">More...</a><br /></td></tr>
<tr class="separator:afe66720a34c11920f359394a4430a16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75fd791f0b8fca724e5ed70b4956414"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SFINAE &gt; </td></tr>
<tr class="memitem:ab75fd791f0b8fca724e5ed70b4956414"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer</a> = JSONSerializer&lt; T, SFINAE &gt;</td></tr>
<tr class="separator:ab75fd791f0b8fca724e5ed70b4956414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebde9badb4f1b4cf6517f6b8e302d0d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2ebde9badb4f1b4cf6517f6b8e302d0d">error_handler_t</a> = <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">detail::error_handler_t</a></td></tr>
<tr class="memdesc:a2ebde9badb4f1b4cf6517f6b8e302d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat decoding errors  <a href="#a2ebde9badb4f1b4cf6517f6b8e302d0d">More...</a><br /></td></tr>
<tr class="separator:a2ebde9badb4f1b4cf6517f6b8e302d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067b4f0e63e55055272fec0a26b5b991"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a067b4f0e63e55055272fec0a26b5b991">cbor_tag_handler_t</a> = <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">detail::cbor_tag_handler_t</a></td></tr>
<tr class="memdesc:a067b4f0e63e55055272fec0a26b5b991"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat CBOR tags  <a href="#a067b4f0e63e55055272fec0a26b5b991">More...</a><br /></td></tr>
<tr class="separator:a067b4f0e63e55055272fec0a26b5b991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f7c93f896d302ed0b62d983aac53c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> = std::initializer_list&lt; <a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:a21f7c93f896d302ed0b62d983aac53c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper type for initializer lists of <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> values  <a href="#a21f7c93f896d302ed0b62d983aac53c0">More...</a><br /></td></tr>
<tr class="separator:a21f7c93f896d302ed0b62d983aac53c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143e447269d8beb1d02400093eccd018"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a143e447269d8beb1d02400093eccd018">input_format_t</a> = <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">detail::input_format_t</a></td></tr>
<tr class="separator:a143e447269d8beb1d02400093eccd018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefb05e1022be791038db86c9963cec7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acefb05e1022be791038db86c9963cec7">json_sax_t</a> = <a class="el" href="structjson__sax.html">json_sax</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:acefb05e1022be791038db86c9963cec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SAX interface type, see nlohmann::json_sax.  <a href="#acefb05e1022be791038db86c9963cec7">More...</a><br /></td></tr>
<tr class="separator:acefb05e1022be791038db86c9963cec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b6bf8ee18c48f4609c8bdd4bb95107"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a53b6bf8ee18c48f4609c8bdd4bb95107">parse_event_t</a> = <a class="el" href="namespacedetail.html#a47b1bb0bbd3596589ed9187059c312ef">detail::parse_event_t</a></td></tr>
<tr class="memdesc:a53b6bf8ee18c48f4609c8bdd4bb95107"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser event types  <a href="#a53b6bf8ee18c48f4609c8bdd4bb95107">More...</a><br /></td></tr>
<tr class="separator:a53b6bf8ee18c48f4609c8bdd4bb95107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50644d655c9283aaf0e2a0f3a5428867"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a50644d655c9283aaf0e2a0f3a5428867">parser_callback_t</a> = <a class="el" href="namespacedetail.html#a20a6b9b232b9f47ce057fe5cc5bbf511">detail::parser_callback_t</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a50644d655c9283aaf0e2a0f3a5428867"><td class="mdescLeft">&#160;</td><td class="mdescRight">per-element parser callback type  <a href="#a50644d655c9283aaf0e2a0f3a5428867">More...</a><br /></td></tr>
<tr class="separator:a50644d655c9283aaf0e2a0f3a5428867"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb684c446c48759336dc227f16b7d3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a5f2aaec3b681d0a72f7d6e90b70cdcd1">JSON_HEDLEY_RETURNS_NON_NULL</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afb684c446c48759336dc227f16b7d3f4">type_name</a> () const noexcept</td></tr>
<tr class="memdesc:afb684c446c48759336dc227f16b7d3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type as string  <a href="#afb684c446c48759336dc227f16b7d3f4">More...</a><br /></td></tr>
<tr class="separator:afb684c446c48759336dc227f16b7d3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b684342f67317a21b2d9e33ec8feb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> (const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> v)</td></tr>
<tr class="separator:ab4b684342f67317a21b2d9e33ec8feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2430d63f0ffd335f276c085c33c11b17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2430d63f0ffd335f276c085c33c11b17">data</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="separator:a2430d63f0ffd335f276c085c33c11b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8aaf6afe755ea6c586ab9920389d6bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac8aaf6afe755ea6c586ab9920389d6bf">data</a> () noexcept=default</td></tr>
<tr class="separator:ac8aaf6afe755ea6c586ab9920389d6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad05755736ab9e3416f0556bb47a6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a08ad05755736ab9e3416f0556bb47a6a">data</a> (data &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a08ad05755736ab9e3416f0556bb47a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416abf41e6c61061dd2be762a88cceb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a416abf41e6c61061dd2be762a88cceb8">data</a> (const data &amp;) noexcept=delete</td></tr>
<tr class="separator:a416abf41e6c61061dd2be762a88cceb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b114795c5e45d242a88d3e2306114c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac8b114795c5e45d242a88d3e2306114c">operator=</a> (<a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> &amp;&amp;) noexcept=delete</td></tr>
<tr class="separator:ac8b114795c5e45d242a88d3e2306114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345d693c6d7e58a3e486a4436d60956a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a345d693c6d7e58a3e486a4436d60956a">operator=</a> (const <a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> &amp;) noexcept=delete</td></tr>
<tr class="separator:a345d693c6d7e58a3e486a4436d60956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc878691d825f4376b4e177b2818b59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acdc878691d825f4376b4e177b2818b59">~data</a> () noexcept</td></tr>
<tr class="separator:acdc878691d825f4376b4e177b2818b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4bceecf563151eb58af179416d8e6299"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4bceecf563151eb58af179416d8e6299">get_allocator</a> ()</td></tr>
<tr class="memdesc:a4bceecf563151eb58af179416d8e6299"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the allocator associated with the container  <a href="#a4bceecf563151eb58af179416d8e6299">More...</a><br /></td></tr>
<tr class="separator:a4bceecf563151eb58af179416d8e6299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b435c2ed2db99cb1daa78ae3c6c4580"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7b435c2ed2db99cb1daa78ae3c6c4580">meta</a> ()</td></tr>
<tr class="memdesc:a7b435c2ed2db99cb1daa78ae3c6c4580"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns version information on the library  <a href="#a7b435c2ed2db99cb1daa78ae3c6c4580">More...</a><br /></td></tr>
<tr class="separator:a7b435c2ed2db99cb1daa78ae3c6c4580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addedd5e53fa6eff6cd621f1615741c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> bool static SAX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#addedd5e53fa6eff6cd621f1615741c3d">sax_parse</a> (InputType &amp;&amp;i, SAX *sax, <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> format=<a class="el" href="_w_c_sim_l_i_gen_8cc.html#ab701e3ac61a85b337ec5c1abaad6742d">input_format_t::json</a>, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="separator:addedd5e53fa6eff6cd621f1615741c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cbf1844fef86e9301282ad8ca0f822"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , class SAX &gt; </td></tr>
<tr class="memitem:a94cbf1844fef86e9301282ad8ca0f822"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a94cbf1844fef86e9301282ad8ca0f822">sax_parse</a> (IteratorType first, IteratorType last, SAX *sax, <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> format=<a class="el" href="_w_c_sim_l_i_gen_8cc.html#ab701e3ac61a85b337ec5c1abaad6742d">input_format_t::json</a>, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a94cbf1844fef86e9301282ad8ca0f822"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate SAX events  <a href="#a94cbf1844fef86e9301282ad8ca0f822">More...</a><br /></td></tr>
<tr class="separator:a94cbf1844fef86e9301282ad8ca0f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad018e709338c810c56eaad606186a77e"><td class="memTemplParams" colspan="2">template&lt;typename SAX &gt; </td></tr>
<tr class="memitem:ad018e709338c810c56eaad606186a77e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad018e709338c810c56eaad606186a77e">sax_parse</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, SAX *sax, <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> format=<a class="el" href="_w_c_sim_l_i_gen_8cc.html#ab701e3ac61a85b337ec5c1abaad6742d">input_format_t::json</a>, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:ad018e709338c810c56eaad606186a77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate SAX events  <a href="#ad018e709338c810c56eaad606186a77e">More...</a><br /></td></tr>
<tr class="separator:ad018e709338c810c56eaad606186a77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a27054edf6738852b42e0218fe4337e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a27054edf6738852b42e0218fe4337e1c">__pad4__</a>: struct <a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> { <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> m_type = <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a></td></tr>
<tr class="separator:a27054edf6738852b42e0218fe4337e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0f167153f047a246b51858d7c921b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acd0f167153f047a246b51858d7c921b8">m_value</a> = {}</td></tr>
<tr class="memdesc:acd0f167153f047a246b51858d7c921b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">the value of the current element  <a href="#acd0f167153f047a246b51858d7c921b8">More...</a><br /></td></tr>
<tr class="separator:acd0f167153f047a246b51858d7c921b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7fd3c3afd2abb77797652506ab6bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4f7fd3c3afd2abb77797652506ab6bc0">m_data</a> = {}</td></tr>
<tr class="separator:a4f7fd3c3afd2abb77797652506ab6bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aeb9caf9b95ef9e29b440dd1f0c822f74"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> = <a class="el" href="json_8hpp.html#a80b7254e63f199a1f656f07ae551f632">NLOHMANN_BASIC_JSON_TPL</a></td></tr>
<tr class="memdesc:aeb9caf9b95ef9e29b440dd1f0c822f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">workaround type for MSVC  <a href="#aeb9caf9b95ef9e29b440dd1f0c822f74">More...</a><br /></td></tr>
<tr class="separator:aeb9caf9b95ef9e29b440dd1f0c822f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2539b2d00d469e0ff753617abf22e6ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2539b2d00d469e0ff753617abf22e6ce">json_base_class_t</a> = ::nlohmann::detail::json_base_class&lt; CustomBaseClass &gt;</td></tr>
<tr class="separator:a2539b2d00d469e0ff753617abf22e6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632f199bc4b79371487f529cfdcc267c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a632f199bc4b79371487f529cfdcc267c">primitive_iterator_t</a> = ::nlohmann::detail::primitive_iterator_t</td></tr>
<tr class="separator:a632f199bc4b79371487f529cfdcc267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959fc432c8d609d2bebb998fb6b6a1a7"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a959fc432c8d609d2bebb998fb6b6a1a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a959fc432c8d609d2bebb998fb6b6a1a7">internal_iterator</a> = ::nlohmann::detail::internal_iterator&lt; BasicJsonType &gt;</td></tr>
<tr class="separator:a959fc432c8d609d2bebb998fb6b6a1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397adf6b027ef3c202ec3aa6f6c1f149"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a397adf6b027ef3c202ec3aa6f6c1f149"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a397adf6b027ef3c202ec3aa6f6c1f149">iter_impl</a> = ::nlohmann::detail::iter_impl&lt; BasicJsonType &gt;</td></tr>
<tr class="separator:a397adf6b027ef3c202ec3aa6f6c1f149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b10619e48d72b3257ddd92bb5e3cab2"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a0b10619e48d72b3257ddd92bb5e3cab2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0b10619e48d72b3257ddd92bb5e3cab2">iteration_proxy</a> = ::nlohmann::detail::iteration_proxy&lt; Iterator &gt;</td></tr>
<tr class="separator:a0b10619e48d72b3257ddd92bb5e3cab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b525218bf76ba0c3d75bb4c1e30a3a"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:a40b525218bf76ba0c3d75bb4c1e30a3a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a40b525218bf76ba0c3d75bb4c1e30a3a">json_reverse_iterator</a> = ::nlohmann::detail::json_reverse_iterator&lt; Base &gt;</td></tr>
<tr class="separator:a40b525218bf76ba0c3d75bb4c1e30a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b84a1efe204d891a06767be452fdf60"><td class="memTemplParams" colspan="2">template&lt;typename CharType &gt; </td></tr>
<tr class="memitem:a3b84a1efe204d891a06767be452fdf60"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3b84a1efe204d891a06767be452fdf60">output_adapter_t</a> = ::nlohmann::detail::output_adapter_t&lt; CharType &gt;</td></tr>
<tr class="separator:a3b84a1efe204d891a06767be452fdf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b96a2315625383ea8d6dbc466978a9"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a70b96a2315625383ea8d6dbc466978a9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a70b96a2315625383ea8d6dbc466978a9">binary_reader</a> = ::nlohmann::detail::binary_reader&lt; <a class="el" href="classbasic__json.html">basic_json</a>, InputType &gt;</td></tr>
<tr class="separator:a70b96a2315625383ea8d6dbc466978a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0261c797ae5126681e4a68d1e8eacc"><td class="memTemplParams" colspan="2">template&lt;typename CharType &gt; </td></tr>
<tr class="memitem:aed0261c797ae5126681e4a68d1e8eacc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aed0261c797ae5126681e4a68d1e8eacc">binary_writer</a> = ::nlohmann::detail::binary_writer&lt; <a class="el" href="classbasic__json.html">basic_json</a>, CharType &gt;</td></tr>
<tr class="separator:aed0261c797ae5126681e4a68d1e8eacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac9a6dcbf8716e58f662a86c1bbcff565"><td class="memTemplParams" colspan="2">template&lt;typename InputAdapterType &gt; </td></tr>
<tr class="memitem:ac9a6dcbf8716e58f662a86c1bbcff565"><td class="memTemplItemLeft" align="right" valign="top">static ::nlohmann::detail::parser&lt; <a class="el" href="classbasic__json.html">basic_json</a>, InputAdapterType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac9a6dcbf8716e58f662a86c1bbcff565">parser</a> (InputAdapterType adapter, <a class="el" href="namespacedetail.html#a20a6b9b232b9f47ce057fe5cc5bbf511">detail::parser_callback_t</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;cb=nullptr, const bool allow_exceptions=true, const bool ignore_comments=false)</td></tr>
<tr class="separator:ac9a6dcbf8716e58f662a86c1bbcff565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7d5a2a718ecaf2749c23e619897b75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a> ()=default</td></tr>
<tr class="memdesc:ade7d5a2a718ecaf2749c23e619897b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor (for null values)  <a href="#ade7d5a2a718ecaf2749c23e619897b75">More...</a><br /></td></tr>
<tr class="separator:ade7d5a2a718ecaf2749c23e619897b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3c2791c6cac612eb49f44d8e83bb75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2d3c2791c6cac612eb49f44d8e83bb75">json_value</a> (<a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> v) noexcept</td></tr>
<tr class="memdesc:a2d3c2791c6cac612eb49f44d8e83bb75"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for booleans  <a href="#a2d3c2791c6cac612eb49f44d8e83bb75">More...</a><br /></td></tr>
<tr class="separator:a2d3c2791c6cac612eb49f44d8e83bb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8e46eb2120a8f7c63c8d9e62a5b105"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3f8e46eb2120a8f7c63c8d9e62a5b105">json_value</a> (<a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> v) noexcept</td></tr>
<tr class="memdesc:a3f8e46eb2120a8f7c63c8d9e62a5b105"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for numbers (integer)  <a href="#a3f8e46eb2120a8f7c63c8d9e62a5b105">More...</a><br /></td></tr>
<tr class="separator:a3f8e46eb2120a8f7c63c8d9e62a5b105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff2f2def587632ebb64a2a1d921f39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5eff2f2def587632ebb64a2a1d921f39">json_value</a> (<a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> v) noexcept</td></tr>
<tr class="memdesc:a5eff2f2def587632ebb64a2a1d921f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for numbers (unsigned)  <a href="#a5eff2f2def587632ebb64a2a1d921f39">More...</a><br /></td></tr>
<tr class="separator:a5eff2f2def587632ebb64a2a1d921f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b174d239bcc49866f2f4d2a5ed82a99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6b174d239bcc49866f2f4d2a5ed82a99">json_value</a> (<a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> v) noexcept</td></tr>
<tr class="memdesc:a6b174d239bcc49866f2f4d2a5ed82a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for numbers (floating-point)  <a href="#a6b174d239bcc49866f2f4d2a5ed82a99">More...</a><br /></td></tr>
<tr class="separator:a6b174d239bcc49866f2f4d2a5ed82a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad919ffad986df2c11159792ba4f733f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad919ffad986df2c11159792ba4f733f2">json_value</a> (<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> t)</td></tr>
<tr class="memdesc:ad919ffad986df2c11159792ba4f733f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for empty values of a given type  <a href="#ad919ffad986df2c11159792ba4f733f2">More...</a><br /></td></tr>
<tr class="separator:ad919ffad986df2c11159792ba4f733f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668dcc1acf6c8872d9aea15c9946922f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a668dcc1acf6c8872d9aea15c9946922f">json_value</a> (const <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:a668dcc1acf6c8872d9aea15c9946922f"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for strings  <a href="#a668dcc1acf6c8872d9aea15c9946922f">More...</a><br /></td></tr>
<tr class="separator:a668dcc1acf6c8872d9aea15c9946922f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578593b5d6dd782f1296b6a81acb57df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a578593b5d6dd782f1296b6a81acb57df">json_value</a> (<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &amp;&amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:a578593b5d6dd782f1296b6a81acb57df"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for rvalue strings  <a href="#a578593b5d6dd782f1296b6a81acb57df">More...</a><br /></td></tr>
<tr class="separator:a578593b5d6dd782f1296b6a81acb57df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97b5eb40b7491b17a4707db9452603d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa97b5eb40b7491b17a4707db9452603d">json_value</a> (const <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> &amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:aa97b5eb40b7491b17a4707db9452603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for objects  <a href="#aa97b5eb40b7491b17a4707db9452603d">More...</a><br /></td></tr>
<tr class="separator:aa97b5eb40b7491b17a4707db9452603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fda1c2f595a47099c152caf497b715"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a07fda1c2f595a47099c152caf497b715">json_value</a> (<a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> &amp;&amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:a07fda1c2f595a47099c152caf497b715"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for rvalue objects  <a href="#a07fda1c2f595a47099c152caf497b715">More...</a><br /></td></tr>
<tr class="separator:a07fda1c2f595a47099c152caf497b715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1472b1d7dccf1de47b28185457f7e08c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1472b1d7dccf1de47b28185457f7e08c">json_value</a> (const <a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> &amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:a1472b1d7dccf1de47b28185457f7e08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for arrays  <a href="#a1472b1d7dccf1de47b28185457f7e08c">More...</a><br /></td></tr>
<tr class="separator:a1472b1d7dccf1de47b28185457f7e08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea2025deef694f8bcf98b52b9c4a1da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4ea2025deef694f8bcf98b52b9c4a1da">json_value</a> (<a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> &amp;&amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:a4ea2025deef694f8bcf98b52b9c4a1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for rvalue arrays  <a href="#a4ea2025deef694f8bcf98b52b9c4a1da">More...</a><br /></td></tr>
<tr class="separator:a4ea2025deef694f8bcf98b52b9c4a1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe346424b682748764754e236cd8c89d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afe346424b682748764754e236cd8c89d">json_value</a> (const typename binary_t::container_type &amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:afe346424b682748764754e236cd8c89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for binary arrays  <a href="#afe346424b682748764754e236cd8c89d">More...</a><br /></td></tr>
<tr class="separator:afe346424b682748764754e236cd8c89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c04c85a95df9e2fcad67398fff07f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a08c04c85a95df9e2fcad67398fff07f2">json_value</a> (typename binary_t::container_type &amp;&amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:a08c04c85a95df9e2fcad67398fff07f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for rvalue binary arrays  <a href="#a08c04c85a95df9e2fcad67398fff07f2">More...</a><br /></td></tr>
<tr class="separator:a08c04c85a95df9e2fcad67398fff07f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecd9db0d04a7981f6b09bbf67c3ebef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aeecd9db0d04a7981f6b09bbf67c3ebef">json_value</a> (const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:aeecd9db0d04a7981f6b09bbf67c3ebef"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for binary arrays (internal type)  <a href="#aeecd9db0d04a7981f6b09bbf67c3ebef">More...</a><br /></td></tr>
<tr class="separator:aeecd9db0d04a7981f6b09bbf67c3ebef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47f2e94e50be0fe53a457f382f93a31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa47f2e94e50be0fe53a457f382f93a31">json_value</a> (<a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;&amp;<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:aa47f2e94e50be0fe53a457f382f93a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for rvalue binary arrays (internal type)  <a href="#aa47f2e94e50be0fe53a457f382f93a31">More...</a><br /></td></tr>
<tr class="separator:aa47f2e94e50be0fe53a457f382f93a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5699c685383c0e4c824a084cb36e99ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5699c685383c0e4c824a084cb36e99ba">destroy</a> (<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> t)</td></tr>
<tr class="separator:a5699c685383c0e4c824a084cb36e99ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ffa8ef2d9d5971619fdac9012ae8dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a54ffa8ef2d9d5971619fdac9012ae8dd">assert_invariant</a> (bool check_parents=true) const noexcept</td></tr>
<tr class="memdesc:a54ffa8ef2d9d5971619fdac9012ae8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks the class invariants  <a href="#a54ffa8ef2d9d5971619fdac9012ae8dd">More...</a><br /></td></tr>
<tr class="separator:a54ffa8ef2d9d5971619fdac9012ae8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960be8bb5f127dd11c33d861622a5fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a960be8bb5f127dd11c33d861622a5fa7">set_parents</a> ()</td></tr>
<tr class="separator:a960be8bb5f127dd11c33d861622a5fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd445a8a1ccb0ef0302b00529543a9ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abd445a8a1ccb0ef0302b00529543a9ba">set_parents</a> (<a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> it, typename iterator::difference_type count_set_parents)</td></tr>
<tr class="separator:abd445a8a1ccb0ef0302b00529543a9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f3fc8d1028c1bee49974c0b62b2611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a01f3fc8d1028c1bee49974c0b62b2611">set_parent</a> (<a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> j, std::size_t old_capacity=static_cast&lt; std::size_t &gt;(-1))</td></tr>
<tr class="separator:a01f3fc8d1028c1bee49974c0b62b2611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fda70d85381ed122d055de8ff66da3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2fda70d85381ed122d055de8ff66da3c">get_impl</a> (<a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> *) const</td></tr>
<tr class="memdesc:a2fda70d85381ed122d055de8ff66da3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a boolean (explicit)  <a href="#a2fda70d85381ed122d055de8ff66da3c">More...</a><br /></td></tr>
<tr class="separator:a2fda70d85381ed122d055de8ff66da3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f697c50a38725496e42a802fa66bb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0f697c50a38725496e42a802fa66bb4e">get_impl_ptr</a> (<a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> *) noexcept</td></tr>
<tr class="memdesc:a0f697c50a38725496e42a802fa66bb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (object)  <a href="#a0f697c50a38725496e42a802fa66bb4e">More...</a><br /></td></tr>
<tr class="separator:a0f697c50a38725496e42a802fa66bb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a08a020217904ff6ab57a6b038a53f"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a62a08a020217904ff6ab57a6b038a53f">get_impl_ptr</a> (const <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> *) const noexcept</td></tr>
<tr class="memdesc:a62a08a020217904ff6ab57a6b038a53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (object)  <a href="#a62a08a020217904ff6ab57a6b038a53f">More...</a><br /></td></tr>
<tr class="separator:a62a08a020217904ff6ab57a6b038a53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9296e26efdc92aef5abd921d0c60f06e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9296e26efdc92aef5abd921d0c60f06e">get_impl_ptr</a> (<a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> *) noexcept</td></tr>
<tr class="memdesc:a9296e26efdc92aef5abd921d0c60f06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (array)  <a href="#a9296e26efdc92aef5abd921d0c60f06e">More...</a><br /></td></tr>
<tr class="separator:a9296e26efdc92aef5abd921d0c60f06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05cb55fe32eacfada85a9e0d15efd90"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af05cb55fe32eacfada85a9e0d15efd90">get_impl_ptr</a> (const <a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> *) const noexcept</td></tr>
<tr class="memdesc:af05cb55fe32eacfada85a9e0d15efd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (array)  <a href="#af05cb55fe32eacfada85a9e0d15efd90">More...</a><br /></td></tr>
<tr class="separator:af05cb55fe32eacfada85a9e0d15efd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a7ea5ec94c08d22a7a1005c9ba562b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae0a7ea5ec94c08d22a7a1005c9ba562b">get_impl_ptr</a> (<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> *) noexcept</td></tr>
<tr class="memdesc:ae0a7ea5ec94c08d22a7a1005c9ba562b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (string)  <a href="#ae0a7ea5ec94c08d22a7a1005c9ba562b">More...</a><br /></td></tr>
<tr class="separator:ae0a7ea5ec94c08d22a7a1005c9ba562b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650606981b67fc120771fb34c6b0f474"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a650606981b67fc120771fb34c6b0f474">get_impl_ptr</a> (const <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> *) const noexcept</td></tr>
<tr class="memdesc:a650606981b67fc120771fb34c6b0f474"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (string)  <a href="#a650606981b67fc120771fb34c6b0f474">More...</a><br /></td></tr>
<tr class="separator:a650606981b67fc120771fb34c6b0f474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecece12aa58729cc5fe4cf7f248a5b9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aecece12aa58729cc5fe4cf7f248a5b9e">get_impl_ptr</a> (<a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> *) noexcept</td></tr>
<tr class="memdesc:aecece12aa58729cc5fe4cf7f248a5b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (boolean)  <a href="#aecece12aa58729cc5fe4cf7f248a5b9e">More...</a><br /></td></tr>
<tr class="separator:aecece12aa58729cc5fe4cf7f248a5b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8289f33035c6ae9bdf3d04ffcd2fcf8"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac8289f33035c6ae9bdf3d04ffcd2fcf8">get_impl_ptr</a> (const <a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> *) const noexcept</td></tr>
<tr class="memdesc:ac8289f33035c6ae9bdf3d04ffcd2fcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (boolean)  <a href="#ac8289f33035c6ae9bdf3d04ffcd2fcf8">More...</a><br /></td></tr>
<tr class="separator:ac8289f33035c6ae9bdf3d04ffcd2fcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1d3f85882b53f0dea8b83e11d18af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5a1d3f85882b53f0dea8b83e11d18af5">get_impl_ptr</a> (<a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> *) noexcept</td></tr>
<tr class="memdesc:a5a1d3f85882b53f0dea8b83e11d18af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (integer number)  <a href="#a5a1d3f85882b53f0dea8b83e11d18af5">More...</a><br /></td></tr>
<tr class="separator:a5a1d3f85882b53f0dea8b83e11d18af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d69984f4830a270cde1f49684035fc"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a77d69984f4830a270cde1f49684035fc">get_impl_ptr</a> (const <a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> *) const noexcept</td></tr>
<tr class="memdesc:a77d69984f4830a270cde1f49684035fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (integer number)  <a href="#a77d69984f4830a270cde1f49684035fc">More...</a><br /></td></tr>
<tr class="separator:a77d69984f4830a270cde1f49684035fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ed866b63af3b306fc2ef938f0acd06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a99ed866b63af3b306fc2ef938f0acd06">get_impl_ptr</a> (<a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> *) noexcept</td></tr>
<tr class="memdesc:a99ed866b63af3b306fc2ef938f0acd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (unsigned number)  <a href="#a99ed866b63af3b306fc2ef938f0acd06">More...</a><br /></td></tr>
<tr class="separator:a99ed866b63af3b306fc2ef938f0acd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba5c2afc523f10792f36e3c2b16de25"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1ba5c2afc523f10792f36e3c2b16de25">get_impl_ptr</a> (const <a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> *) const noexcept</td></tr>
<tr class="memdesc:a1ba5c2afc523f10792f36e3c2b16de25"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (unsigned number)  <a href="#a1ba5c2afc523f10792f36e3c2b16de25">More...</a><br /></td></tr>
<tr class="separator:a1ba5c2afc523f10792f36e3c2b16de25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843a72226992ad9cbe5d131249b5772d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a843a72226992ad9cbe5d131249b5772d">get_impl_ptr</a> (<a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> *) noexcept</td></tr>
<tr class="memdesc:a843a72226992ad9cbe5d131249b5772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (floating-point number)  <a href="#a843a72226992ad9cbe5d131249b5772d">More...</a><br /></td></tr>
<tr class="separator:a843a72226992ad9cbe5d131249b5772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812bf5a6b4ff44ebef6542ed150a2244"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a812bf5a6b4ff44ebef6542ed150a2244">get_impl_ptr</a> (const <a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> *) const noexcept</td></tr>
<tr class="memdesc:a812bf5a6b4ff44ebef6542ed150a2244"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (floating-point number)  <a href="#a812bf5a6b4ff44ebef6542ed150a2244">More...</a><br /></td></tr>
<tr class="separator:a812bf5a6b4ff44ebef6542ed150a2244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af366aaa5f0ba4591a334503219a32d4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af366aaa5f0ba4591a334503219a32d4a">get_impl_ptr</a> (<a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> *) noexcept</td></tr>
<tr class="memdesc:af366aaa5f0ba4591a334503219a32d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (binary)  <a href="#af366aaa5f0ba4591a334503219a32d4a">More...</a><br /></td></tr>
<tr class="separator:af366aaa5f0ba4591a334503219a32d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0065d89c2ba863b8a849e89389f6b947"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0065d89c2ba863b8a849e89389f6b947">get_impl_ptr</a> (const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> *) const noexcept</td></tr>
<tr class="memdesc:a0065d89c2ba863b8a849e89389f6b947"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to the value (binary)  <a href="#a0065d89c2ba863b8a849e89389f6b947">More...</a><br /></td></tr>
<tr class="separator:a0065d89c2ba863b8a849e89389f6b947"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a0647e7717e43d080e02aa762eedd33f7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a0647e7717e43d080e02aa762eedd33f7"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a5f2aaec3b681d0a72f7d6e90b70cdcd1">JSON_HEDLEY_RETURNS_NON_NULL</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0647e7717e43d080e02aa762eedd33f7">create</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0647e7717e43d080e02aa762eedd33f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for exception-safe object creation  <a href="#a0647e7717e43d080e02aa762eedd33f7">More...</a><br /></td></tr>
<tr class="separator:a0647e7717e43d080e02aa762eedd33f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb599679fd8e475a5c82a7098d2f693"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename ThisType &gt; </td></tr>
<tr class="memitem:a3fb599679fd8e475a5c82a7098d2f693"><td class="memTemplItemLeft" align="right" valign="top">static ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3fb599679fd8e475a5c82a7098d2f693">get_ref_impl</a> (ThisType &amp;obj)</td></tr>
<tr class="memdesc:a3fb599679fd8e475a5c82a7098d2f693"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to implement <a class="el" href="classbasic__json.html#a3697078e748abc4a99c23e36e321b439" title="get a reference value (implicit) ">get_ref()</a>  <a href="#a3fb599679fd8e475a5c82a7098d2f693">More...</a><br /></td></tr>
<tr class="separator:a3fb599679fd8e475a5c82a7098d2f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa82137724f80ebaa92ec6544eb5e544a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa82137724f80ebaa92ec6544eb5e544a">__pad0__</a>: using lexer = ::nlohmann::detail::lexer_base&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td></tr>
<tr class="separator:aa82137724f80ebaa92ec6544eb5e544a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1d2f61621d0cb05507f5a48d25fb26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acb1d2f61621d0cb05507f5a48d25fb26">__pad1__</a>: using serializer = ::nlohmann::detail::serializer&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td></tr>
<tr class="separator:acb1d2f61621d0cb05507f5a48d25fb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0831d0e3207eb079fb274eb0d3dcc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4c0831d0e3207eb079fb274eb0d3dcc5">__pad2__</a>: union <a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a> { <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a>* <a class="el" href="classbasic__json.html#a50a0e8dacc0f4aa12162da666595e6fd">object</a></td></tr>
<tr class="separator:a4c0831d0e3207eb079fb274eb0d3dcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5299b166ebd27030235e2314a0cf5882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5299b166ebd27030235e2314a0cf5882">array</a></td></tr>
<tr class="memdesc:a5299b166ebd27030235e2314a0cf5882"><td class="mdescLeft">&#160;</td><td class="mdescRight">array (stored with pointer to save storage)  <a href="#a5299b166ebd27030235e2314a0cf5882">More...</a><br /></td></tr>
<tr class="separator:a5299b166ebd27030235e2314a0cf5882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814cc0333d9ecea13eb0554fd35df8ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a814cc0333d9ecea13eb0554fd35df8ec">string</a></td></tr>
<tr class="memdesc:a814cc0333d9ecea13eb0554fd35df8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">string (stored with pointer to save storage)  <a href="#a814cc0333d9ecea13eb0554fd35df8ec">More...</a><br /></td></tr>
<tr class="separator:a814cc0333d9ecea13eb0554fd35df8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba94a85b63eab2443e7fab8cb26d150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8ba94a85b63eab2443e7fab8cb26d150">binary</a></td></tr>
<tr class="memdesc:a8ba94a85b63eab2443e7fab8cb26d150"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary (stored with pointer to save storage)  <a href="#a8ba94a85b63eab2443e7fab8cb26d150">More...</a><br /></td></tr>
<tr class="separator:a8ba94a85b63eab2443e7fab8cb26d150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe268377946f15ff7b309b887e8ef8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afe268377946f15ff7b309b887e8ef8ac">boolean</a></td></tr>
<tr class="memdesc:afe268377946f15ff7b309b887e8ef8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">boolean  <a href="#afe268377946f15ff7b309b887e8ef8ac">More...</a><br /></td></tr>
<tr class="separator:afe268377946f15ff7b309b887e8ef8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda00ee3da4d87072260cf07d1143f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acda00ee3da4d87072260cf07d1143f62">number_integer</a></td></tr>
<tr class="memdesc:acda00ee3da4d87072260cf07d1143f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">number (integer)  <a href="#acda00ee3da4d87072260cf07d1143f62">More...</a><br /></td></tr>
<tr class="separator:acda00ee3da4d87072260cf07d1143f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a54245650ef57a6d8375592821a5344"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0a54245650ef57a6d8375592821a5344">number_unsigned</a></td></tr>
<tr class="memdesc:a0a54245650ef57a6d8375592821a5344"><td class="mdescLeft">&#160;</td><td class="mdescRight">number (unsigned integer)  <a href="#a0a54245650ef57a6d8375592821a5344">More...</a><br /></td></tr>
<tr class="separator:a0a54245650ef57a6d8375592821a5344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dca98c209830ac0cf1019fa99e0031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a10dca98c209830ac0cf1019fa99e0031">number_float</a></td></tr>
<tr class="memdesc:a10dca98c209830ac0cf1019fa99e0031"><td class="mdescLeft">&#160;</td><td class="mdescRight">number (floating-point)  <a href="#a10dca98c209830ac0cf1019fa99e0031">More...</a><br /></td></tr>
<tr class="separator:a10dca98c209830ac0cf1019fa99e0031"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplParams" colspan="2">template&lt;detail::value_t &gt; </td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6275ed57bae6866cdf5db5370a7ad47c">detail::external_constructor</a></td></tr>
<tr class="separator:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f901b14cf3f7135269b0c75c9ac233"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a43f901b14cf3f7135269b0c75c9ac233"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a43f901b14cf3f7135269b0c75c9ac233">::nlohmann::json_pointer</a></td></tr>
<tr class="separator:a43f901b14cf3f7135269b0c75c9ac233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f3125911eb018ef4ab00d879487baf"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename InputType &gt; </td></tr>
<tr class="memitem:ac8f3125911eb018ef4ab00d879487baf"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac8f3125911eb018ef4ab00d879487baf">::nlohmann::detail::parser</a></td></tr>
<tr class="separator:ac8f3125911eb018ef4ab00d879487baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842e5c7ca096025c18b11e715d3401f4"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a842e5c7ca096025c18b11e715d3401f4"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a842e5c7ca096025c18b11e715d3401f4">::nlohmann::detail::iter_impl</a></td></tr>
<tr class="separator:a842e5c7ca096025c18b11e715d3401f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename CharType &gt; </td></tr>
<tr class="memitem:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a69d491bbda88ade6d3c7a2b11309e8bf">::nlohmann::detail::binary_writer</a></td></tr>
<tr class="separator:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa226ed5103dfd10e27e562d35a3a106b"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename InputType , typename SAX &gt; </td></tr>
<tr class="memitem:aa226ed5103dfd10e27e562d35a3a106b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa226ed5103dfd10e27e562d35a3a106b">::nlohmann::detail::binary_reader</a></td></tr>
<tr class="separator:aa226ed5103dfd10e27e562d35a3a106b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a47aabb1eceae32e8a6e8e7f0ff34be60">::nlohmann::detail::json_sax_dom_parser</a></td></tr>
<tr class="separator:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95574da8d12905ea99dc348934c837da"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a95574da8d12905ea99dc348934c837da"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a95574da8d12905ea99dc348934c837da">::nlohmann::detail::json_sax_dom_callback_parser</a></td></tr>
<tr class="separator:a95574da8d12905ea99dc348934c837da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcb15d025676b4d3db0f32a50f4393f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abdcb15d025676b4d3db0f32a50f4393f">::nlohmann::detail::exception</a></td></tr>
<tr class="separator:abdcb15d025676b4d3db0f32a50f4393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ca396028b8d9714c6e10efbf475af6"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a60ca396028b8d9714c6e10efbf475af6">operator&lt;&lt;</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;j, std::istream &amp;i)</td></tr>
<tr class="memdesc:a60ca396028b8d9714c6e10efbf475af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="#a60ca396028b8d9714c6e10efbf475af6">More...</a><br /></td></tr>
<tr class="separator:a60ca396028b8d9714c6e10efbf475af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf363408931d76472ded14017e59c9e8"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:aaf363408931d76472ded14017e59c9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="#aaf363408931d76472ded14017e59c9e8">More...</a><br /></td></tr>
<tr class="separator:aaf363408931d76472ded14017e59c9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
exceptions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp19ad27801b95bd1f2c6c2bf83dbb7515"></a>Classes to implement user-defined exceptions. </p>
</td></tr>
<tr class="memitem:a4ed57fa411e69ae5741bc2f333a967c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4ed57fa411e69ae5741bc2f333a967c9">exception</a> = <a class="el" href="classdetail_1_1exception.html">detail::exception</a></td></tr>
<tr class="separator:a4ed57fa411e69ae5741bc2f333a967c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe1802a6a2de032f3c4e4f0f555ae10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0fe1802a6a2de032f3c4e4f0f555ae10">parse_error</a> = <a class="el" href="classdetail_1_1parse__error.html">detail::parse_error</a></td></tr>
<tr class="separator:a0fe1802a6a2de032f3c4e4f0f555ae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b69b2a91df080e00cc8f36c342bb6b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a34b69b2a91df080e00cc8f36c342bb6b">invalid_iterator</a> = <a class="el" href="classdetail_1_1invalid__iterator.html">detail::invalid_iterator</a></td></tr>
<tr class="separator:a34b69b2a91df080e00cc8f36c342bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c52f112e54d1be294055ea9186a1c35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2c52f112e54d1be294055ea9186a1c35">type_error</a> = <a class="el" href="classdetail_1_1type__error.html">detail::type_error</a></td></tr>
<tr class="separator:a2c52f112e54d1be294055ea9186a1c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45e2d88a6cf9236c1f45a1fad18442d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa45e2d88a6cf9236c1f45a1fad18442d">out_of_range</a> = <a class="el" href="classdetail_1_1out__of__range.html">detail::out_of_range</a></td></tr>
<tr class="separator:aa45e2d88a6cf9236c1f45a1fad18442d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d18607e0835c4695f53996b181379"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adb2d18607e0835c4695f53996b181379">other_error</a> = <a class="el" href="classdetail_1_1other__error.html">detail::other_error</a></td></tr>
<tr class="separator:adb2d18607e0835c4695f53996b181379"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
container types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6618fa684bc6d5a05e2c88bfff1c0d66"></a>The canonic container types to use <a class="el" href="classbasic__json.html">basic_json</a> like any other STL container. </p>
</td></tr>
<tr class="memitem:a0d9e6a7acee2992e310ea21a7b59c67a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0d9e6a7acee2992e310ea21a7b59c67a">value_type</a> = <a class="el" href="classbasic__json.html">basic_json</a></td></tr>
<tr class="memdesc:a0d9e6a7acee2992e310ea21a7b59c67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of elements in a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container  <a href="#a0d9e6a7acee2992e310ea21a7b59c67a">More...</a><br /></td></tr>
<tr class="separator:a0d9e6a7acee2992e310ea21a7b59c67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca7bfb35987ce7cb8d27447cda5b80a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> = <a class="el" href="classbasic__json.html#a0d9e6a7acee2992e310ea21a7b59c67a">value_type</a> &amp;</td></tr>
<tr class="memdesc:a6ca7bfb35987ce7cb8d27447cda5b80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element reference  <a href="#a6ca7bfb35987ce7cb8d27447cda5b80a">More...</a><br /></td></tr>
<tr class="separator:a6ca7bfb35987ce7cb8d27447cda5b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31370bb451b78198d42c86dd31955deb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> = const <a class="el" href="classbasic__json.html#a0d9e6a7acee2992e310ea21a7b59c67a">value_type</a> &amp;</td></tr>
<tr class="memdesc:a31370bb451b78198d42c86dd31955deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const reference  <a href="#a31370bb451b78198d42c86dd31955deb">More...</a><br /></td></tr>
<tr class="separator:a31370bb451b78198d42c86dd31955deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45e8f7ce7c3e62035cd097a39910399"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae45e8f7ce7c3e62035cd097a39910399">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:ae45e8f7ce7c3e62035cd097a39910399"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent differences between iterators  <a href="#ae45e8f7ce7c3e62035cd097a39910399">More...</a><br /></td></tr>
<tr class="separator:ae45e8f7ce7c3e62035cd097a39910399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c086af43cf06b1b7118f5351cab3ec9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a2c086af43cf06b1b7118f5351cab3ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent container sizes  <a href="#a2c086af43cf06b1b7118f5351cab3ec9">More...</a><br /></td></tr>
<tr class="separator:a2c086af43cf06b1b7118f5351cab3ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f845db2d54cedad97279bad70aea52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a> = AllocatorType&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a83f845db2d54cedad97279bad70aea52"><td class="mdescLeft">&#160;</td><td class="mdescRight">the allocator type  <a href="#a83f845db2d54cedad97279bad70aea52">More...</a><br /></td></tr>
<tr class="separator:a83f845db2d54cedad97279bad70aea52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84279673ab13fb6360cf17173a29a1f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a84279673ab13fb6360cf17173a29a1f1">pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a> &gt;::<a class="el" href="classbasic__json.html#a84279673ab13fb6360cf17173a29a1f1">pointer</a></td></tr>
<tr class="memdesc:a84279673ab13fb6360cf17173a29a1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element pointer  <a href="#a84279673ab13fb6360cf17173a29a1f1">More...</a><br /></td></tr>
<tr class="separator:a84279673ab13fb6360cf17173a29a1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2862fa42527f5c14d9f737411e0facd4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2862fa42527f5c14d9f737411e0facd4">const_pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a> &gt;::<a class="el" href="classbasic__json.html#a2862fa42527f5c14d9f737411e0facd4">const_pointer</a></td></tr>
<tr class="memdesc:a2862fa42527f5c14d9f737411e0facd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const pointer  <a href="#a2862fa42527f5c14d9f737411e0facd4">More...</a><br /></td></tr>
<tr class="separator:a2862fa42527f5c14d9f737411e0facd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206a491161d043f8efaa1330f1ccf97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> = <a class="el" href="classbasic__json.html#a397adf6b027ef3c202ec3aa6f6c1f149">iter_impl</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:ae206a491161d043f8efaa1330f1ccf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">an iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container  <a href="#ae206a491161d043f8efaa1330f1ccf97">More...</a><br /></td></tr>
<tr class="separator:ae206a491161d043f8efaa1330f1ccf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5af3d9d06d43b91fefe1767794b1e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> = <a class="el" href="classbasic__json.html#a397adf6b027ef3c202ec3aa6f6c1f149">iter_impl</a>&lt; const <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a1f5af3d9d06d43b91fefe1767794b1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container  <a href="#a1f5af3d9d06d43b91fefe1767794b1e8">More...</a><br /></td></tr>
<tr class="separator:a1f5af3d9d06d43b91fefe1767794b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc059cdae078322bb0d434b2127d1cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aedc059cdae078322bb0d434b2127d1cf">reverse_iterator</a> = <a class="el" href="classbasic__json.html#a40b525218bf76ba0c3d75bb4c1e30a3a">json_reverse_iterator</a>&lt; typename <a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">basic_json::iterator</a> &gt;</td></tr>
<tr class="memdesc:aedc059cdae078322bb0d434b2127d1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">a reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container  <a href="#aedc059cdae078322bb0d434b2127d1cf">More...</a><br /></td></tr>
<tr class="separator:aedc059cdae078322bb0d434b2127d1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240f61567d8acffe831532f4f9b379cb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a240f61567d8acffe831532f4f9b379cb">const_reverse_iterator</a> = <a class="el" href="classbasic__json.html#a40b525218bf76ba0c3d75bb4c1e30a3a">json_reverse_iterator</a>&lt; typename <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">basic_json::const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a240f61567d8acffe831532f4f9b379cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container  <a href="#a240f61567d8acffe831532f4f9b379cb">More...</a><br /></td></tr>
<tr class="separator:a240f61567d8acffe831532f4f9b379cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
JSON value data types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbddfba6d49869d59bfd397e65b8cba87"></a>The data types to store a JSON value. These types are derived from the template arguments passed to class <a class="el" href="classbasic__json.html">basic_json</a>. </p>
</td></tr>
<tr class="memitem:a991d005e7f648cbf37bb36daf85183ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a991d005e7f648cbf37bb36daf85183ca">default_object_comparator_t</a> = std::less&lt; StringType &gt;</td></tr>
<tr class="memdesc:a991d005e7f648cbf37bb36daf85183ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">default object key comparator type The actual object key comparator type (<a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a>) may be different.  <a href="#a991d005e7f648cbf37bb36daf85183ca">More...</a><br /></td></tr>
<tr class="separator:a991d005e7f648cbf37bb36daf85183ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90f70623dc1ad761ea1c5013b2fee47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> = ObjectType&lt; StringType, <a class="el" href="classbasic__json.html">basic_json</a>, <a class="el" href="classbasic__json.html#a991d005e7f648cbf37bb36daf85183ca">default_object_comparator_t</a>, AllocatorType&lt; std::pair&lt; const StringType, <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ac90f70623dc1ad761ea1c5013b2fee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an object  <a href="#ac90f70623dc1ad761ea1c5013b2fee47">More...</a><br /></td></tr>
<tr class="separator:ac90f70623dc1ad761ea1c5013b2fee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b282cae56b331d222c7da4b05eab5e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> = ArrayType&lt; <a class="el" href="classbasic__json.html">basic_json</a>, AllocatorType&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:a6b282cae56b331d222c7da4b05eab5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an array  <a href="#a6b282cae56b331d222c7da4b05eab5e8">More...</a><br /></td></tr>
<tr class="separator:a6b282cae56b331d222c7da4b05eab5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c9cde32146e6c343e1960aefc11fba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> = StringType</td></tr>
<tr class="memdesc:ac8c9cde32146e6c343e1960aefc11fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a string  <a href="#ac8c9cde32146e6c343e1960aefc11fba">More...</a><br /></td></tr>
<tr class="separator:ac8c9cde32146e6c343e1960aefc11fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9301890c48e9b957edc07f9eb767bd10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> = BooleanType</td></tr>
<tr class="memdesc:a9301890c48e9b957edc07f9eb767bd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a boolean  <a href="#a9301890c48e9b957edc07f9eb767bd10">More...</a><br /></td></tr>
<tr class="separator:a9301890c48e9b957edc07f9eb767bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba48b0bdee31228a4e19b7c040b6d2a5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> = NumberIntegerType</td></tr>
<tr class="memdesc:aba48b0bdee31228a4e19b7c040b6d2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (integer)  <a href="#aba48b0bdee31228a4e19b7c040b6d2a5">More...</a><br /></td></tr>
<tr class="separator:aba48b0bdee31228a4e19b7c040b6d2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8505b599e706768a1e0bd6718cc7117"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> = NumberUnsignedType</td></tr>
<tr class="memdesc:ae8505b599e706768a1e0bd6718cc7117"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (unsigned)  <a href="#ae8505b599e706768a1e0bd6718cc7117">More...</a><br /></td></tr>
<tr class="separator:ae8505b599e706768a1e0bd6718cc7117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a229dbc84c1334171ce9c49c873c56"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> = NumberFloatType</td></tr>
<tr class="memdesc:a80a229dbc84c1334171ce9c49c873c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (floating-point)  <a href="#a80a229dbc84c1334171ce9c49c873c56">More...</a><br /></td></tr>
<tr class="separator:a80a229dbc84c1334171ce9c49c873c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1b5ea434b48cf31097617bb1c1ca1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> = nlohmann::byte_container_with_subtype&lt; <a class="el" href="class_binary_type.html">BinaryType</a> &gt;</td></tr>
<tr class="memdesc:a4c1b5ea434b48cf31097617bb1c1ca1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a packed binary type  <a href="#a4c1b5ea434b48cf31097617bb1c1ca1e">More...</a><br /></td></tr>
<tr class="separator:a4c1b5ea434b48cf31097617bb1c1ca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12040e0663db54840d73d363979643a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a> = <a class="el" href="namespacedetail.html#acf3e5af512080ec5b71496dde9e0651c">detail::actual_object_comparator_t</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:af12040e0663db54840d73d363979643a"><td class="mdescLeft">&#160;</td><td class="mdescRight">object key comparator type  <a href="#af12040e0663db54840d73d363979643a">More...</a><br /></td></tr>
<tr class="separator:af12040e0663db54840d73d363979643a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
constructors and destructors</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd94b4d3d0135946bb7bdf25e48755337"></a>Constructors of class <a class="el" href="classbasic__json.html">basic_json</a>, copy/move constructor, copy assignment, static functions creating objects, and the destructor. </p>
</td></tr>
<tr class="memitem:a743ac3bcbc4b0f7897244d4cea387eee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a743ac3bcbc4b0f7897244d4cea387eee">binary</a> (const typename binary_t::container_type &amp;init)</td></tr>
<tr class="memdesc:a743ac3bcbc4b0f7897244d4cea387eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="#a743ac3bcbc4b0f7897244d4cea387eee">More...</a><br /></td></tr>
<tr class="separator:a743ac3bcbc4b0f7897244d4cea387eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e65e73d9ecf780537d632372fa2c51"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a45e65e73d9ecf780537d632372fa2c51">binary</a> (const typename binary_t::container_type &amp;init, typename binary_t::subtype_type subtype)</td></tr>
<tr class="memdesc:a45e65e73d9ecf780537d632372fa2c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <a href="#a45e65e73d9ecf780537d632372fa2c51">More...</a><br /></td></tr>
<tr class="separator:a45e65e73d9ecf780537d632372fa2c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af2196a9acde33f742ef054e7c2109c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5af2196a9acde33f742ef054e7c2109c">binary</a> (typename binary_t::container_type &amp;&amp;init)</td></tr>
<tr class="memdesc:a5af2196a9acde33f742ef054e7c2109c"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array  <a href="#a5af2196a9acde33f742ef054e7c2109c">More...</a><br /></td></tr>
<tr class="separator:a5af2196a9acde33f742ef054e7c2109c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00a2a38929ce21eae65f9dd09b03ce3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac00a2a38929ce21eae65f9dd09b03ce3">binary</a> (typename binary_t::container_type &amp;&amp;init, typename binary_t::subtype_type subtype)</td></tr>
<tr class="memdesc:ac00a2a38929ce21eae65f9dd09b03ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <a href="#ac00a2a38929ce21eae65f9dd09b03ce3">More...</a><br /></td></tr>
<tr class="separator:ac00a2a38929ce21eae65f9dd09b03ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac736994a792cb8460a30a3f4dd86fd78"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac736994a792cb8460a30a3f4dd86fd78">array</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:ac736994a792cb8460a30a3f4dd86fd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create an array from an initializer list  <a href="#ac736994a792cb8460a30a3f4dd86fd78">More...</a><br /></td></tr>
<tr class="separator:ac736994a792cb8460a30a3f4dd86fd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a0e8dacc0f4aa12162da666595e6fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a50a0e8dacc0f4aa12162da666595e6fd">object</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:a50a0e8dacc0f4aa12162da666595e6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create an object from an initializer list  <a href="#a50a0e8dacc0f4aa12162da666595e6fd">More...</a><br /></td></tr>
<tr class="separator:a50a0e8dacc0f4aa12162da666595e6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d5bc42270881ed3e219e8b1456fec5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae2d5bc42270881ed3e219e8b1456fec5">basic_json</a> (const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> v)</td></tr>
<tr class="memdesc:ae2d5bc42270881ed3e219e8b1456fec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an empty value with a given type  <a href="#ae2d5bc42270881ed3e219e8b1456fec5">More...</a><br /></td></tr>
<tr class="separator:ae2d5bc42270881ed3e219e8b1456fec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1fab9ded0a2a182837bd66c0e5189e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5b1fab9ded0a2a182837bd66c0e5189e">basic_json</a> (std::nullptr_t=nullptr) noexcept</td></tr>
<tr class="memdesc:a5b1fab9ded0a2a182837bd66c0e5189e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a null object  <a href="#a5b1fab9ded0a2a182837bd66c0e5189e">More...</a><br /></td></tr>
<tr class="separator:a5b1fab9ded0a2a182837bd66c0e5189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a631fcf93bb88189959be86a3c914f9"><td class="memTemplParams" colspan="2">template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, detail::enable_if_t&lt; !detail::is_basic_json&lt; U &gt;::value &amp;&amp;detail::is_compatible_type&lt; basic_json_t, U &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7a631fcf93bb88189959be86a3c914f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7a631fcf93bb88189959be86a3c914f9">basic_json</a> (CompatibleType &amp;&amp;val) noexcept(noexcept(//NOLINT(bugprone-forwarding-<a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>-overload, bugprone-<a class="el" href="classbasic__json.html#a4ed57fa411e69ae5741bc2f333a967c9">exception</a>-escape) JSONSerializer&lt; U &gt;::to_json(std::declval&lt; <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;(), std::forward&lt; CompatibleType &gt;(val))))</td></tr>
<tr class="memdesc:a7a631fcf93bb88189959be86a3c914f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from compatible types  <a href="#a7a631fcf93bb88189959be86a3c914f9">More...</a><br /></td></tr>
<tr class="separator:a7a631fcf93bb88189959be86a3c914f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf10402e79a1acce9a74f5a9654d403"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;!std::is_same&lt; basic_json, BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aeaf10402e79a1acce9a74f5a9654d403"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aeaf10402e79a1acce9a74f5a9654d403">basic_json</a> (const BasicJsonType &amp;val)</td></tr>
<tr class="memdesc:aeaf10402e79a1acce9a74f5a9654d403"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an existing one  <a href="#aeaf10402e79a1acce9a74f5a9654d403">More...</a><br /></td></tr>
<tr class="separator:aeaf10402e79a1acce9a74f5a9654d403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa911d47d3c99184a301bf4fd304199b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa911d47d3c99184a301bf4fd304199b2">basic_json</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init, bool type_deduction=true, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> manual_type=<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>)</td></tr>
<tr class="memdesc:aa911d47d3c99184a301bf4fd304199b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a container (array or object) from an initializer list  <a href="#aa911d47d3c99184a301bf4fd304199b2">More...</a><br /></td></tr>
<tr class="separator:aa911d47d3c99184a301bf4fd304199b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6f0605b09a002567fd18a289cef31b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7b6f0605b09a002567fd18a289cef31b">basic_json</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a7b6f0605b09a002567fd18a289cef31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct an array with count copies of given value  <a href="#a7b6f0605b09a002567fd18a289cef31b">More...</a><br /></td></tr>
<tr class="separator:a7b6f0605b09a002567fd18a289cef31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97b4fcd01509076c8a7b32ec1a10aec"><td class="memTemplParams" colspan="2">template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;::value||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:af97b4fcd01509076c8a7b32ec1a10aec"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af97b4fcd01509076c8a7b32ec1a10aec">basic_json</a> (InputIT first, InputIT last)</td></tr>
<tr class="memdesc:af97b4fcd01509076c8a7b32ec1a10aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a JSON container given an iterator range  <a href="#af97b4fcd01509076c8a7b32ec1a10aec">More...</a><br /></td></tr>
<tr class="separator:af97b4fcd01509076c8a7b32ec1a10aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6712795591ec744415b50bc01d768ed"><td class="memTemplParams" colspan="2">template&lt;typename JsonRef , detail::enable_if_t&lt; detail::conjunction&lt; detail::is_json_ref&lt; JsonRef &gt;, std::is_same&lt; typename JsonRef::value_type, basic_json &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab6712795591ec744415b50bc01d768ed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab6712795591ec744415b50bc01d768ed">basic_json</a> (const JsonRef &amp;ref)</td></tr>
<tr class="separator:ab6712795591ec744415b50bc01d768ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15244e1249b6e7282127d460b5b2e3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af15244e1249b6e7282127d460b5b2e3e">basic_json</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;other)</td></tr>
<tr class="memdesc:af15244e1249b6e7282127d460b5b2e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#af15244e1249b6e7282127d460b5b2e3e">More...</a><br /></td></tr>
<tr class="separator:af15244e1249b6e7282127d460b5b2e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18629aae4bd76e6f7920cf4e7b4dd60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae18629aae4bd76e6f7920cf4e7b4dd60">basic_json</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ae18629aae4bd76e6f7920cf4e7b4dd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="#ae18629aae4bd76e6f7920cf4e7b4dd60">More...</a><br /></td></tr>
<tr class="separator:ae18629aae4bd76e6f7920cf4e7b4dd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b20f4ac45a0f6e5ac2a2fb6138c19f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab0b20f4ac45a0f6e5ac2a2fb6138c19f">operator=</a> (<a class="el" href="classbasic__json.html">basic_json</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; <a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="classbasic__json.html#a2539b2d00d469e0ff753617abf22e6ce">json_base_class_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:ab0b20f4ac45a0f6e5ac2a2fb6138c19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment  <a href="#ab0b20f4ac45a0f6e5ac2a2fb6138c19f">More...</a><br /></td></tr>
<tr class="separator:ab0b20f4ac45a0f6e5ac2a2fb6138c19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3bcb6dc54f447ad95085715104494e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9f3bcb6dc54f447ad95085715104494e">~basic_json</a> () noexcept</td></tr>
<tr class="memdesc:a9f3bcb6dc54f447ad95085715104494e"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#a9f3bcb6dc54f447ad95085715104494e">More...</a><br /></td></tr>
<tr class="separator:a9f3bcb6dc54f447ad95085715104494e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
object inspection</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbbb01a37b8f261ae5b5799058dcac1a0"></a>Functions to inspect the type of a JSON value. </p>
</td></tr>
<tr class="memitem:a85df48caed9e341bb14d98ab88891d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a85df48caed9e341bb14d98ab88891d1e">dump</a> (const int indent=-1, const char indent_char=' ', const bool ensure_ascii=false, const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a> error_handler=error_handler_t::strict) const</td></tr>
<tr class="memdesc:a85df48caed9e341bb14d98ab88891d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialization  <a href="#a85df48caed9e341bb14d98ab88891d1e">More...</a><br /></td></tr>
<tr class="separator:a85df48caed9e341bb14d98ab88891d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e52dbb3cb4e9fcabd1b88c37985aef"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac5e52dbb3cb4e9fcabd1b88c37985aef">type</a> () const noexcept</td></tr>
<tr class="memdesc:ac5e52dbb3cb4e9fcabd1b88c37985aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type of the JSON value (explicit)  <a href="#ac5e52dbb3cb4e9fcabd1b88c37985aef">More...</a><br /></td></tr>
<tr class="separator:ac5e52dbb3cb4e9fcabd1b88c37985aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad650dd5a7e019b970abce3d8864b5654"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad650dd5a7e019b970abce3d8864b5654">is_primitive</a> () const noexcept</td></tr>
<tr class="memdesc:ad650dd5a7e019b970abce3d8864b5654"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether type is primitive  <a href="#ad650dd5a7e019b970abce3d8864b5654">More...</a><br /></td></tr>
<tr class="separator:ad650dd5a7e019b970abce3d8864b5654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3a5f8761bc6f163f4119bddaf7b092"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2d3a5f8761bc6f163f4119bddaf7b092">is_structured</a> () const noexcept</td></tr>
<tr class="memdesc:a2d3a5f8761bc6f163f4119bddaf7b092"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether type is structured  <a href="#a2d3a5f8761bc6f163f4119bddaf7b092">More...</a><br /></td></tr>
<tr class="separator:a2d3a5f8761bc6f163f4119bddaf7b092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8789d0a365d5afaab61e7492908d8b2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad8789d0a365d5afaab61e7492908d8b2">is_null</a> () const noexcept</td></tr>
<tr class="memdesc:ad8789d0a365d5afaab61e7492908d8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is null  <a href="#ad8789d0a365d5afaab61e7492908d8b2">More...</a><br /></td></tr>
<tr class="separator:ad8789d0a365d5afaab61e7492908d8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2e3c359b545f8edbb72f6bd78718c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acfe2e3c359b545f8edbb72f6bd78718c">is_boolean</a> () const noexcept</td></tr>
<tr class="memdesc:acfe2e3c359b545f8edbb72f6bd78718c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a boolean  <a href="#acfe2e3c359b545f8edbb72f6bd78718c">More...</a><br /></td></tr>
<tr class="separator:acfe2e3c359b545f8edbb72f6bd78718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf244be5088fb183f4ba21a66af9631"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aacf244be5088fb183f4ba21a66af9631">is_number</a> () const noexcept</td></tr>
<tr class="memdesc:aacf244be5088fb183f4ba21a66af9631"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a number  <a href="#aacf244be5088fb183f4ba21a66af9631">More...</a><br /></td></tr>
<tr class="separator:aacf244be5088fb183f4ba21a66af9631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2330e35cda16540058fef090abc709bf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2330e35cda16540058fef090abc709bf">is_number_integer</a> () const noexcept</td></tr>
<tr class="memdesc:a2330e35cda16540058fef090abc709bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an integer number  <a href="#a2330e35cda16540058fef090abc709bf">More...</a><br /></td></tr>
<tr class="separator:a2330e35cda16540058fef090abc709bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de72635745144ee519157d23fe7189a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4de72635745144ee519157d23fe7189a">is_number_unsigned</a> () const noexcept</td></tr>
<tr class="memdesc:a4de72635745144ee519157d23fe7189a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an unsigned integer number  <a href="#a4de72635745144ee519157d23fe7189a">More...</a><br /></td></tr>
<tr class="separator:a4de72635745144ee519157d23fe7189a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bb82dfc8cceae1753b52a588eef92"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8d5bb82dfc8cceae1753b52a588eef92">is_number_float</a> () const noexcept</td></tr>
<tr class="memdesc:a8d5bb82dfc8cceae1753b52a588eef92"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a floating-point number  <a href="#a8d5bb82dfc8cceae1753b52a588eef92">More...</a><br /></td></tr>
<tr class="separator:a8d5bb82dfc8cceae1753b52a588eef92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af355a2b131068acf3d623eb6d80a711c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af355a2b131068acf3d623eb6d80a711c">is_object</a> () const noexcept</td></tr>
<tr class="memdesc:af355a2b131068acf3d623eb6d80a711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an object  <a href="#af355a2b131068acf3d623eb6d80a711c">More...</a><br /></td></tr>
<tr class="separator:af355a2b131068acf3d623eb6d80a711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184ba4a6b47e6da3703af19349bd776f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a184ba4a6b47e6da3703af19349bd776f">is_array</a> () const noexcept</td></tr>
<tr class="memdesc:a184ba4a6b47e6da3703af19349bd776f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an array  <a href="#a184ba4a6b47e6da3703af19349bd776f">More...</a><br /></td></tr>
<tr class="separator:a184ba4a6b47e6da3703af19349bd776f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007ecebde9a7d40714e300ce0ff52908"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a007ecebde9a7d40714e300ce0ff52908">is_string</a> () const noexcept</td></tr>
<tr class="memdesc:a007ecebde9a7d40714e300ce0ff52908"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a string  <a href="#a007ecebde9a7d40714e300ce0ff52908">More...</a><br /></td></tr>
<tr class="separator:a007ecebde9a7d40714e300ce0ff52908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdd993df08641faa3e24b5d2151e8f8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abbdd993df08641faa3e24b5d2151e8f8">is_binary</a> () const noexcept</td></tr>
<tr class="memdesc:abbdd993df08641faa3e24b5d2151e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a binary array  <a href="#abbdd993df08641faa3e24b5d2151e8f8">More...</a><br /></td></tr>
<tr class="separator:abbdd993df08641faa3e24b5d2151e8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e4946a414cc978b88939ed1b343d46"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a39e4946a414cc978b88939ed1b343d46">is_discarded</a> () const noexcept</td></tr>
<tr class="memdesc:a39e4946a414cc978b88939ed1b343d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is discarded  <a href="#a39e4946a414cc978b88939ed1b343d46">More...</a><br /></td></tr>
<tr class="separator:a39e4946a414cc978b88939ed1b343d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e1c8fbdb62f3f8bc04e69eef9cc9cf"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a70e1c8fbdb62f3f8bc04e69eef9cc9cf">operator value_t</a> () const noexcept</td></tr>
<tr class="memdesc:a70e1c8fbdb62f3f8bc04e69eef9cc9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type of the JSON value (implicit)  <a href="#a70e1c8fbdb62f3f8bc04e69eef9cc9cf">More...</a><br /></td></tr>
<tr class="separator:a70e1c8fbdb62f3f8bc04e69eef9cc9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
value access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd8f53c9caf18314e5b3f758245606995"></a>Direct access to the stored value of a JSON value. </p>
</td></tr>
<tr class="memitem:aa2a895b06bd5de2d9a059083a9a3a582"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , detail::enable_if_t&lt; detail::is_default_constructible&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa2a895b06bd5de2d9a059083a9a3a582"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa2a895b06bd5de2d9a059083a9a3a582">get_impl</a> (<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 0 &gt;) const noexcept(noexcept(JSONSerializer&lt; ValueType &gt;::from_json(std::declval&lt; const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;(), std::declval&lt; ValueType &amp;&gt;())))</td></tr>
<tr class="memdesc:aa2a895b06bd5de2d9a059083a9a3a582"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (explicit)  <a href="#aa2a895b06bd5de2d9a059083a9a3a582">More...</a><br /></td></tr>
<tr class="separator:aa2a895b06bd5de2d9a059083a9a3a582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4ced744fab1a861ec51e82928ec249"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , detail::enable_if_t&lt; detail::has_non_default_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6f4ced744fab1a861ec51e82928ec249"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6f4ced744fab1a861ec51e82928ec249">get_impl</a> (<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 1 &gt;) const noexcept(noexcept(JSONSerializer&lt; ValueType &gt;::from_json(std::declval&lt; const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;())))</td></tr>
<tr class="memdesc:a6f4ced744fab1a861ec51e82928ec249"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (explicit); special case  <a href="#a6f4ced744fab1a861ec51e82928ec249">More...</a><br /></td></tr>
<tr class="separator:a6f4ced744fab1a861ec51e82928ec249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f1255b2138773aa57bf2e22c71a315"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a76f1255b2138773aa57bf2e22c71a315"><td class="memTemplItemLeft" align="right" valign="top">BasicJsonType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a76f1255b2138773aa57bf2e22c71a315">get_impl</a> (<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 2 &gt;) const</td></tr>
<tr class="memdesc:a76f1255b2138773aa57bf2e22c71a315"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="#a76f1255b2138773aa57bf2e22c71a315">More...</a><br /></td></tr>
<tr class="separator:a76f1255b2138773aa57bf2e22c71a315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2632e75860da5fd88f079de332a77059"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; std::is_same&lt; BasicJsonType, basic_json_t &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2632e75860da5fd88f079de332a77059"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2632e75860da5fd88f079de332a77059">get_impl</a> (<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 3 &gt;) const</td></tr>
<tr class="memdesc:a2632e75860da5fd88f079de332a77059"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="#a2632e75860da5fd88f079de332a77059">More...</a><br /></td></tr>
<tr class="separator:a2632e75860da5fd88f079de332a77059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5900ef7d593fd56b0a65cd36c6cea727"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , detail::enable_if_t&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5900ef7d593fd56b0a65cd36c6cea727"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5900ef7d593fd56b0a65cd36c6cea727">get_impl</a> (<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt;) const noexcept -&gt; decltype(std::declval&lt; const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;().template <a class="el" href="classbasic__json.html#a8d6d588e99e9f5eeaf3da5155cc57418">get_ptr</a>&lt; PointerType &gt;())</td></tr>
<tr class="memdesc:a5900ef7d593fd56b0a65cd36c6cea727"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (explicit)  <a href="#a5900ef7d593fd56b0a65cd36c6cea727">More...</a><br /></td></tr>
<tr class="separator:a5900ef7d593fd56b0a65cd36c6cea727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6d588e99e9f5eeaf3da5155cc57418"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a8d6d588e99e9f5eeaf3da5155cc57418"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8d6d588e99e9f5eeaf3da5155cc57418">get_ptr</a> () noexcept -&gt; decltype(std::declval&lt; <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;().<a class="el" href="classbasic__json.html#a0f697c50a38725496e42a802fa66bb4e">get_impl_ptr</a>(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:a8d6d588e99e9f5eeaf3da5155cc57418"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (implicit)  <a href="#a8d6d588e99e9f5eeaf3da5155cc57418">More...</a><br /></td></tr>
<tr class="separator:a8d6d588e99e9f5eeaf3da5155cc57418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6047ca56f3416ff0bcab2cc6908a51"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a9c6047ca56f3416ff0bcab2cc6908a51"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9c6047ca56f3416ff0bcab2cc6908a51">get_ptr</a> () const noexcept -&gt; decltype(std::declval&lt; const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;().<a class="el" href="classbasic__json.html#a0f697c50a38725496e42a802fa66bb4e">get_impl_ptr</a>(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:a9c6047ca56f3416ff0bcab2cc6908a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (implicit)  <a href="#a9c6047ca56f3416ff0bcab2cc6908a51">More...</a><br /></td></tr>
<tr class="separator:a9c6047ca56f3416ff0bcab2cc6908a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa157d688b97ca85fbcdcb19b769f458"><td class="memTemplParams" colspan="2">template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;&gt; </td></tr>
<tr class="memitem:afa157d688b97ca85fbcdcb19b769f458"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afa157d688b97ca85fbcdcb19b769f458">get</a> () const noexcept(noexcept(std::declval&lt; const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;().template <a class="el" href="classbasic__json.html#a2fda70d85381ed122d055de8ff66da3c">get_impl</a>&lt; ValueType &gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt; {}))) -&gt; decltype(std::declval&lt; const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;().template <a class="el" href="classbasic__json.html#a2fda70d85381ed122d055de8ff66da3c">get_impl</a>&lt; ValueType &gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt;</td></tr>
<tr class="memdesc:afa157d688b97ca85fbcdcb19b769f458"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a (pointer) value (explicit)  <a href="#afa157d688b97ca85fbcdcb19b769f458">More...</a><br /></td></tr>
<tr class="separator:afa157d688b97ca85fbcdcb19b769f458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb17a8039a7027e1a51a03952cf1bd3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="verification___hits_charge_time_8_c.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acb17a8039a7027e1a51a03952cf1bd3d">get_impl</a> (<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt; {})</td></tr>
<tr class="separator:acb17a8039a7027e1a51a03952cf1bd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ed0f6ce2d46a800e930fb7525c6611"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ac0ed0f6ce2d46a800e930fb7525c6611"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac0ed0f6ce2d46a800e930fb7525c6611">get</a> () noexcept -&gt; decltype(std::declval&lt; <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;().template <a class="el" href="classbasic__json.html#a8d6d588e99e9f5eeaf3da5155cc57418">get_ptr</a>&lt; PointerType &gt;())</td></tr>
<tr class="memdesc:ac0ed0f6ce2d46a800e930fb7525c6611"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (explicit)  <a href="#ac0ed0f6ce2d46a800e930fb7525c6611">More...</a><br /></td></tr>
<tr class="separator:ac0ed0f6ce2d46a800e930fb7525c6611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c5290f8d96616959270719f6507b8a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , detail::enable_if_t&lt; !detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae0c5290f8d96616959270719f6507b8a"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae0c5290f8d96616959270719f6507b8a">get_to</a> (ValueType &amp;v) const noexcept(noexcept(JSONSerializer&lt; ValueType &gt;::from_json(std::declval&lt; const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;(), v)))</td></tr>
<tr class="memdesc:ae0c5290f8d96616959270719f6507b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (explicit)  <a href="#ae0c5290f8d96616959270719f6507b8a">More...</a><br /></td></tr>
<tr class="separator:ae0c5290f8d96616959270719f6507b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b5d8cbbde2eb425b55690024b1a5a1"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , detail::enable_if_t&lt; detail::is_basic_json&lt; ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81b5d8cbbde2eb425b55690024b1a5a1"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a81b5d8cbbde2eb425b55690024b1a5a1">get_to</a> (ValueType &amp;v) const</td></tr>
<tr class="separator:a81b5d8cbbde2eb425b55690024b1a5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6779b8151c44de5f7ca9208a04e0f127"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename Array  = T (&amp;)[N], detail::enable_if_t&lt; detail::has_from_json&lt; basic_json_t, Array &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6779b8151c44de5f7ca9208a04e0f127"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6779b8151c44de5f7ca9208a04e0f127">get_to</a> (T(&amp;v)[N]) const noexcept(noexcept(JSONSerializer&lt; Array &gt;::from_json(std::declval&lt; const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> &amp;&gt;(), v)))</td></tr>
<tr class="separator:a6779b8151c44de5f7ca9208a04e0f127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3697078e748abc4a99c23e36e321b439"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a3697078e748abc4a99c23e36e321b439"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3697078e748abc4a99c23e36e321b439">get_ref</a> ()</td></tr>
<tr class="memdesc:a3697078e748abc4a99c23e36e321b439"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference value (implicit)  <a href="#a3697078e748abc4a99c23e36e321b439">More...</a><br /></td></tr>
<tr class="separator:a3697078e748abc4a99c23e36e321b439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c5dbafcc6eef79143c251096827549"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a39c5dbafcc6eef79143c251096827549"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a39c5dbafcc6eef79143c251096827549">get_ref</a> () const</td></tr>
<tr class="memdesc:a39c5dbafcc6eef79143c251096827549"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference value (implicit)  <a href="#a39c5dbafcc6eef79143c251096827549">More...</a><br /></td></tr>
<tr class="separator:a39c5dbafcc6eef79143c251096827549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747e3e19891143442991bbdb33edb917"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename std::enable_if&lt; detail::conjunction&lt; detail::negation&lt; std::is_pointer&lt; ValueType &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, std::nullptr_t &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, detail::json_ref&lt; basic_json &gt;&gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, typename string_t::value_type &gt;&gt;, detail::negation&lt; detail::is_basic_json&lt; ValueType &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt;&gt;&gt;, detail::is_detected_lazy&lt; detail::get_template_function, const basic_json_t &amp;, ValueType &gt; &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a747e3e19891143442991bbdb33edb917"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#aefed8cf27cadeea45f12c6f3db3ce774">JSON_EXPLICIT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a747e3e19891143442991bbdb33edb917">operator ValueType</a> () const</td></tr>
<tr class="memdesc:a747e3e19891143442991bbdb33edb917"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (implicit)  <a href="#a747e3e19891143442991bbdb33edb917">More...</a><br /></td></tr>
<tr class="separator:a747e3e19891143442991bbdb33edb917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55de1b3601085c32e4a1dc32ef6d32d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac55de1b3601085c32e4a1dc32ef6d32d">get_binary</a> ()</td></tr>
<tr class="memdesc:ac55de1b3601085c32e4a1dc32ef6d32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a binary value  <a href="#ac55de1b3601085c32e4a1dc32ef6d32d">More...</a><br /></td></tr>
<tr class="separator:ac55de1b3601085c32e4a1dc32ef6d32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab13e0430cfea76c05ccd062aa528ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4ab13e0430cfea76c05ccd062aa528ec">get_binary</a> () const</td></tr>
<tr class="memdesc:a4ab13e0430cfea76c05ccd062aa528ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a binary value  <a href="#a4ab13e0430cfea76c05ccd062aa528ec">More...</a><br /></td></tr>
<tr class="separator:a4ab13e0430cfea76c05ccd062aa528ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
element access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf68418821a90b03a001117a613b131dd"></a>Access to the JSON value. </p>
</td></tr>
<tr class="memitem:a10771c460900f2f8cac0841d48ab3e30"><td class="memTemplParams" colspan="2">template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:a10771c460900f2f8cac0841d48ab3e30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a10771c460900f2f8cac0841d48ab3e30">is_comparable_with_object_key</a> = <a class="el" href="structdetail_1_1is__comparable.html">detail::is_comparable</a>&lt; <a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a>, const typename object_t::key_type &amp;, KeyType &gt;</td></tr>
<tr class="separator:a10771c460900f2f8cac0841d48ab3e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d2f51d8300e987422052ff3f4a4064"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a96d2f51d8300e987422052ff3f4a4064"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a96d2f51d8300e987422052ff3f4a4064">value_return_type</a> = std::conditional&lt; <a class="el" href="namespacedetail.html#a9d99cdff6fa6a48145e5f7209d60db5a">detail::is_c_string_uncvref</a>&lt; ValueType &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>, <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>, typename std::decay&lt; ValueType &gt;::<a class="el" href="classstd_1_1conditional_1_1type.html">type</a> &gt;</td></tr>
<tr class="separator:a96d2f51d8300e987422052ff3f4a4064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9737aa07030fa0c9e2909d2c5c03f460"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , detail::enable_if_t&lt; detail::has_erase_with_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9737aa07030fa0c9e2909d2c5c03f460"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9737aa07030fa0c9e2909d2c5c03f460">erase_internal</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="separator:a9737aa07030fa0c9e2909d2c5c03f460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9737aa07030fa0c9e2909d2c5c03f460"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , detail::enable_if_t&lt; !detail::has_erase_with_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9737aa07030fa0c9e2909d2c5c03f460"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9737aa07030fa0c9e2909d2c5c03f460">erase_internal</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="separator:a9737aa07030fa0c9e2909d2c5c03f460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899e4623fe377af5c9ad14c40c64280c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a899e4623fe377af5c9ad14c40c64280c">at</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx)</td></tr>
<tr class="memdesc:a899e4623fe377af5c9ad14c40c64280c"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element with bounds checking  <a href="#a899e4623fe377af5c9ad14c40c64280c">More...</a><br /></td></tr>
<tr class="separator:a899e4623fe377af5c9ad14c40c64280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af076d8a80f4263cf821da2033d5773b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af076d8a80f4263cf821da2033d5773b6">at</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx) const</td></tr>
<tr class="memdesc:af076d8a80f4263cf821da2033d5773b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element with bounds checking  <a href="#af076d8a80f4263cf821da2033d5773b6">More...</a><br /></td></tr>
<tr class="separator:af076d8a80f4263cf821da2033d5773b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accafaaf23f60bb245ddb1fa0972b33a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#accafaaf23f60bb245ddb1fa0972b33a3">at</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:accafaaf23f60bb245ddb1fa0972b33a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="#accafaaf23f60bb245ddb1fa0972b33a3">More...</a><br /></td></tr>
<tr class="separator:accafaaf23f60bb245ddb1fa0972b33a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd9ba2f2164d9cee83b07f76d40843f"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4cd9ba2f2164d9cee83b07f76d40843f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4cd9ba2f2164d9cee83b07f76d40843f">at</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a4cd9ba2f2164d9cee83b07f76d40843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="#a4cd9ba2f2164d9cee83b07f76d40843f">More...</a><br /></td></tr>
<tr class="separator:a4cd9ba2f2164d9cee83b07f76d40843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9a21714e81e98fc5786a2339ea1665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aba9a21714e81e98fc5786a2339ea1665">at</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:aba9a21714e81e98fc5786a2339ea1665"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="#aba9a21714e81e98fc5786a2339ea1665">More...</a><br /></td></tr>
<tr class="separator:aba9a21714e81e98fc5786a2339ea1665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6267ca4bd85e25f61dc5ba30204da"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7ae6267ca4bd85e25f61dc5ba30204da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7ae6267ca4bd85e25f61dc5ba30204da">at</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a7ae6267ca4bd85e25f61dc5ba30204da"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="#a7ae6267ca4bd85e25f61dc5ba30204da">More...</a><br /></td></tr>
<tr class="separator:a7ae6267ca4bd85e25f61dc5ba30204da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f511db82b9d5eba85d5b2b8e1c6dbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab4f511db82b9d5eba85d5b2b8e1c6dbb">operator[]</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx)</td></tr>
<tr class="memdesc:ab4f511db82b9d5eba85d5b2b8e1c6dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element  <a href="#ab4f511db82b9d5eba85d5b2b8e1c6dbb">More...</a><br /></td></tr>
<tr class="separator:ab4f511db82b9d5eba85d5b2b8e1c6dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae369d1565482903c3af75bf99467776b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae369d1565482903c3af75bf99467776b">operator[]</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx) const</td></tr>
<tr class="memdesc:ae369d1565482903c3af75bf99467776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element  <a href="#ae369d1565482903c3af75bf99467776b">More...</a><br /></td></tr>
<tr class="separator:ae369d1565482903c3af75bf99467776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5825034534bf9256a33d2dd995c25a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9c5825034534bf9256a33d2dd995c25a">operator[]</a> (typename object_t::key_type key)</td></tr>
<tr class="memdesc:a9c5825034534bf9256a33d2dd995c25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="#a9c5825034534bf9256a33d2dd995c25a">More...</a><br /></td></tr>
<tr class="separator:a9c5825034534bf9256a33d2dd995c25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3ea17617e94886f3e86ac921095a13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3d3ea17617e94886f3e86ac921095a13">operator[]</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:a3d3ea17617e94886f3e86ac921095a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="#a3d3ea17617e94886f3e86ac921095a13">More...</a><br /></td></tr>
<tr class="separator:a3d3ea17617e94886f3e86ac921095a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cae3810ae0a9c56b17842b06fc405e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87cae3810ae0a9c56b17842b06fc405e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a87cae3810ae0a9c56b17842b06fc405e">operator[]</a> (T *key)</td></tr>
<tr class="separator:a87cae3810ae0a9c56b17842b06fc405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12a4386e6913012ca4dffa0245fdf99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab12a4386e6913012ca4dffa0245fdf99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab12a4386e6913012ca4dffa0245fdf99">operator[]</a> (T *key) const</td></tr>
<tr class="separator:ab12a4386e6913012ca4dffa0245fdf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe1a1c7aa8c193c73aa40b17ee5f68"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a06fe1a1c7aa8c193c73aa40b17ee5f68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a06fe1a1c7aa8c193c73aa40b17ee5f68">operator[]</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a06fe1a1c7aa8c193c73aa40b17ee5f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="#a06fe1a1c7aa8c193c73aa40b17ee5f68">More...</a><br /></td></tr>
<tr class="separator:a06fe1a1c7aa8c193c73aa40b17ee5f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e11a3f2a234cd296b515173b6a3b986"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2e11a3f2a234cd296b515173b6a3b986"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2e11a3f2a234cd296b515173b6a3b986">operator[]</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a2e11a3f2a234cd296b515173b6a3b986"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="#a2e11a3f2a234cd296b515173b6a3b986">More...</a><br /></td></tr>
<tr class="separator:a2e11a3f2a234cd296b515173b6a3b986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c2436388fd16a1529ce9afce8229ef"><td class="memTemplParams" colspan="2">template&lt;class ValueType , detail::enable_if_t&lt; !detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a80c2436388fd16a1529ce9afce8229ef"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> (const typename object_t::key_type &amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a80c2436388fd16a1529ce9afce8229ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <a href="#a80c2436388fd16a1529ce9afce8229ef">More...</a><br /></td></tr>
<tr class="separator:a80c2436388fd16a1529ce9afce8229ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56244e0ed0943ad62faf61b06e7ba139"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; !detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a56244e0ed0943ad62faf61b06e7ba139"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a56244e0ed0943ad62faf61b06e7ba139">value</a> (const typename object_t::key_type &amp;key, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:a56244e0ed0943ad62faf61b06e7ba139"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <a href="#a56244e0ed0943ad62faf61b06e7ba139">More...</a><br /></td></tr>
<tr class="separator:a56244e0ed0943ad62faf61b06e7ba139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe572bbfbd4687a7a9167465e4d41f2"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class KeyType , detail::enable_if_t&lt; detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;is_comparable_with_object_key&lt; KeyType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acbe572bbfbd4687a7a9167465e4d41f2"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acbe572bbfbd4687a7a9167465e4d41f2">value</a> (KeyType &amp;&amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:acbe572bbfbd4687a7a9167465e4d41f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <a href="#acbe572bbfbd4687a7a9167465e4d41f2">More...</a><br /></td></tr>
<tr class="separator:acbe572bbfbd4687a7a9167465e4d41f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694398741710ce1c22797ad47109898b"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class KeyType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;is_comparable_with_object_key&lt; KeyType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a694398741710ce1c22797ad47109898b"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a694398741710ce1c22797ad47109898b">value</a> (KeyType &amp;&amp;key, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:a694398741710ce1c22797ad47109898b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <a href="#a694398741710ce1c22797ad47109898b">More...</a><br /></td></tr>
<tr class="separator:a694398741710ce1c22797ad47109898b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63045992eb552c11f77fefddd801591"><td class="memTemplParams" colspan="2">template&lt;class ValueType , detail::enable_if_t&lt; detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac63045992eb552c11f77fefddd801591"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac63045992eb552c11f77fefddd801591">value</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:ac63045992eb552c11f77fefddd801591"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <a href="#ac63045992eb552c11f77fefddd801591">More...</a><br /></td></tr>
<tr class="separator:ac63045992eb552c11f77fefddd801591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab7b5edf8e5831195940f8d377a6ee3"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1ab7b5edf8e5831195940f8d377a6ee3"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1ab7b5edf8e5831195940f8d377a6ee3">value</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:a1ab7b5edf8e5831195940f8d377a6ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <a href="#a1ab7b5edf8e5831195940f8d377a6ee3">More...</a><br /></td></tr>
<tr class="separator:a1ab7b5edf8e5831195940f8d377a6ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b67977cfd161b73161fa9341f8a4158"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3b67977cfd161b73161fa9341f8a4158"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3b67977cfd161b73161fa9341f8a4158">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">basic_json::json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">basic_json::string_t</a> &gt;) ValueType <a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>(const</td></tr>
<tr class="memdesc:a3b67977cfd161b73161fa9341f8a4158"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the first element  <a href="#a3b67977cfd161b73161fa9341f8a4158">More...</a><br /></td></tr>
<tr class="separator:a3b67977cfd161b73161fa9341f8a4158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162089e94f24182ba3e4484be63c0c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a162089e94f24182ba3e4484be63c0c1a">front</a> () const</td></tr>
<tr class="memdesc:a162089e94f24182ba3e4484be63c0c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the first element  <a href="#a162089e94f24182ba3e4484be63c0c1a">More...</a><br /></td></tr>
<tr class="separator:a162089e94f24182ba3e4484be63c0c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d93dc1dbdf67a6ee3a5cf1d2439ca77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0d93dc1dbdf67a6ee3a5cf1d2439ca77">back</a> ()</td></tr>
<tr class="memdesc:a0d93dc1dbdf67a6ee3a5cf1d2439ca77"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the last element  <a href="#a0d93dc1dbdf67a6ee3a5cf1d2439ca77">More...</a><br /></td></tr>
<tr class="separator:a0d93dc1dbdf67a6ee3a5cf1d2439ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eee3066cd1ebfea746f9f07fd03f6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a41eee3066cd1ebfea746f9f07fd03f6f">back</a> () const</td></tr>
<tr class="memdesc:a41eee3066cd1ebfea746f9f07fd03f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the last element  <a href="#a41eee3066cd1ebfea746f9f07fd03f6f">More...</a><br /></td></tr>
<tr class="separator:a41eee3066cd1ebfea746f9f07fd03f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0fef086b1b72372113db6ce7446189"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7d0fef086b1b72372113db6ce7446189"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7d0fef086b1b72372113db6ce7446189">erase</a> (IteratorType pos)</td></tr>
<tr class="memdesc:a7d0fef086b1b72372113db6ce7446189"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element given an iterator  <a href="#a7d0fef086b1b72372113db6ce7446189">More...</a><br /></td></tr>
<tr class="separator:a7d0fef086b1b72372113db6ce7446189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437b81c6e968a4192a22bc0de6c4df80"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a437b81c6e968a4192a22bc0de6c4df80"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a437b81c6e968a4192a22bc0de6c4df80">erase</a> (IteratorType first, IteratorType last)</td></tr>
<tr class="memdesc:a437b81c6e968a4192a22bc0de6c4df80"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove elements given an iterator range  <a href="#a437b81c6e968a4192a22bc0de6c4df80">More...</a><br /></td></tr>
<tr class="separator:a437b81c6e968a4192a22bc0de6c4df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05da3b93f2d4a7164589abffaa9acb33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a05da3b93f2d4a7164589abffaa9acb33">erase</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a05da3b93f2d4a7164589abffaa9acb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON object given a key  <a href="#a05da3b93f2d4a7164589abffaa9acb33">More...</a><br /></td></tr>
<tr class="separator:a05da3b93f2d4a7164589abffaa9acb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f763336e84232f38e2d80e142f9820e"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5f763336e84232f38e2d80e142f9820e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5f763336e84232f38e2d80e142f9820e">erase</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a5f763336e84232f38e2d80e142f9820e"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON object given a key  <a href="#a5f763336e84232f38e2d80e142f9820e">More...</a><br /></td></tr>
<tr class="separator:a5f763336e84232f38e2d80e142f9820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c58b5f34c2ff56e27630214f5a9df4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac2c58b5f34c2ff56e27630214f5a9df4">erase</a> (const <a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx)</td></tr>
<tr class="memdesc:ac2c58b5f34c2ff56e27630214f5a9df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON array given an index  <a href="#ac2c58b5f34c2ff56e27630214f5a9df4">More...</a><br /></td></tr>
<tr class="separator:ac2c58b5f34c2ff56e27630214f5a9df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
lookup</h2></td></tr>
<tr class="memitem:a727e3cfb5a874314d8deb12cb53a8105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a727e3cfb5a874314d8deb12cb53a8105">find</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a727e3cfb5a874314d8deb12cb53a8105"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="#a727e3cfb5a874314d8deb12cb53a8105">More...</a><br /></td></tr>
<tr class="separator:a727e3cfb5a874314d8deb12cb53a8105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf93ae61eb63a9e543cafb3f723900c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7bf93ae61eb63a9e543cafb3f723900c">find</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:a7bf93ae61eb63a9e543cafb3f723900c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="#a7bf93ae61eb63a9e543cafb3f723900c">More...</a><br /></td></tr>
<tr class="separator:a7bf93ae61eb63a9e543cafb3f723900c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dd769ce700326266883ba96a98a8f2"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a89dd769ce700326266883ba96a98a8f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a89dd769ce700326266883ba96a98a8f2">find</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a89dd769ce700326266883ba96a98a8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="#a89dd769ce700326266883ba96a98a8f2">More...</a><br /></td></tr>
<tr class="separator:a89dd769ce700326266883ba96a98a8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1bb257797042aef7142c91f35390d8"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afe1bb257797042aef7142c91f35390d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afe1bb257797042aef7142c91f35390d8">find</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:afe1bb257797042aef7142c91f35390d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="#afe1bb257797042aef7142c91f35390d8">More...</a><br /></td></tr>
<tr class="separator:afe1bb257797042aef7142c91f35390d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e1eff03a320299e6a8639a7579ca46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad1e1eff03a320299e6a8639a7579ca46">count</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:ad1e1eff03a320299e6a8639a7579ca46"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of occurrences of a key in a JSON object  <a href="#ad1e1eff03a320299e6a8639a7579ca46">More...</a><br /></td></tr>
<tr class="separator:ad1e1eff03a320299e6a8639a7579ca46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba1cd73d36a2cd58a9da7021b0f7317"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1ba1cd73d36a2cd58a9da7021b0f7317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1ba1cd73d36a2cd58a9da7021b0f7317">count</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a1ba1cd73d36a2cd58a9da7021b0f7317"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of occurrences of a key in a JSON object  <a href="#a1ba1cd73d36a2cd58a9da7021b0f7317">More...</a><br /></td></tr>
<tr class="separator:a1ba1cd73d36a2cd58a9da7021b0f7317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5ea67fe1a4778be5189423e2545d7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afd5ea67fe1a4778be5189423e2545d7a">contains</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:afd5ea67fe1a4778be5189423e2545d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object  <a href="#afd5ea67fe1a4778be5189423e2545d7a">More...</a><br /></td></tr>
<tr class="separator:afd5ea67fe1a4778be5189423e2545d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7053bdd8e9ee2fcb0ca9c54ec85f1297"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7053bdd8e9ee2fcb0ca9c54ec85f1297"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7053bdd8e9ee2fcb0ca9c54ec85f1297">contains</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a7053bdd8e9ee2fcb0ca9c54ec85f1297"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object  <a href="#a7053bdd8e9ee2fcb0ca9c54ec85f1297">More...</a><br /></td></tr>
<tr class="separator:a7053bdd8e9ee2fcb0ca9c54ec85f1297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c37affef3aa8c79cab9f3bfa2cb5e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac4c37affef3aa8c79cab9f3bfa2cb5e1">contains</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:ac4c37affef3aa8c79cab9f3bfa2cb5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object given a JSON pointer  <a href="#ac4c37affef3aa8c79cab9f3bfa2cb5e1">More...</a><br /></td></tr>
<tr class="separator:ac4c37affef3aa8c79cab9f3bfa2cb5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
modifiers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbf24b44a8cc99e648657b164c8aba758"></a>checks whether the container is empty.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/empty/">https://json.nlohmann.me/api/basic_json/empty/</a> returns the number of elements </dd>
<dd>
<a href="https://json.nlohmann.me/api/basic_json/size/">https://json.nlohmann.me/api/basic_json/size/</a> returns the maximum possible number of elements </dd>
<dd>
<a href="https://json.nlohmann.me/api/basic_json/max_size/">https://json.nlohmann.me/api/basic_json/max_size/</a> </dd></dl>
</td></tr>
<tr class="memitem:aee0ae36cbfb0336832ebc0374c3c7679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a> (<a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> left, <a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> right) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; <a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:aee0ae36cbfb0336832ebc0374c3c7679"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="#aee0ae36cbfb0336832ebc0374c3c7679">More...</a><br /></td></tr>
<tr class="separator:aee0ae36cbfb0336832ebc0374c3c7679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac444a656905e3f207ad9fc19275faf25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac444a656905e3f207ad9fc19275faf25">operator+=</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:ac444a656905e3f207ad9fc19275faf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="#ac444a656905e3f207ad9fc19275faf25">More...</a><br /></td></tr>
<tr class="separator:ac444a656905e3f207ad9fc19275faf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca01ca3a9bc310e5c5d067a39dca6933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aca01ca3a9bc310e5c5d067a39dca6933">push_back</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:aca01ca3a9bc310e5c5d067a39dca6933"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="#aca01ca3a9bc310e5c5d067a39dca6933">More...</a><br /></td></tr>
<tr class="separator:aca01ca3a9bc310e5c5d067a39dca6933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4475e951f51506808ca6fe7e77eb38ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4475e951f51506808ca6fe7e77eb38ca">operator+=</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a4475e951f51506808ca6fe7e77eb38ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="#a4475e951f51506808ca6fe7e77eb38ca">More...</a><br /></td></tr>
<tr class="separator:a4475e951f51506808ca6fe7e77eb38ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17fe93acad9b0b991600225dabd42be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af17fe93acad9b0b991600225dabd42be">push_back</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:af17fe93acad9b0b991600225dabd42be"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="#af17fe93acad9b0b991600225dabd42be">More...</a><br /></td></tr>
<tr class="separator:af17fe93acad9b0b991600225dabd42be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996a58d60e4badd9beadfd3e2e7ffdc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a996a58d60e4badd9beadfd3e2e7ffdc1">operator+=</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:a996a58d60e4badd9beadfd3e2e7ffdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="#a996a58d60e4badd9beadfd3e2e7ffdc1">More...</a><br /></td></tr>
<tr class="separator:a996a58d60e4badd9beadfd3e2e7ffdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcacc90f17b156f0b6c8e0430624853"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4fcacc90f17b156f0b6c8e0430624853">push_back</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:a4fcacc90f17b156f0b6c8e0430624853"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="#a4fcacc90f17b156f0b6c8e0430624853">More...</a><br /></td></tr>
<tr class="separator:a4fcacc90f17b156f0b6c8e0430624853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af74b651da5642cd8b77a3ecc635331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3af74b651da5642cd8b77a3ecc635331">operator+=</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:a3af74b651da5642cd8b77a3ecc635331"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="#a3af74b651da5642cd8b77a3ecc635331">More...</a><br /></td></tr>
<tr class="separator:a3af74b651da5642cd8b77a3ecc635331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f0a15957842b188826aea98a9cfd3d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac5f0a15957842b188826aea98a9cfd3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac5f0a15957842b188826aea98a9cfd3d">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac5f0a15957842b188826aea98a9cfd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="#ac5f0a15957842b188826aea98a9cfd3d">More...</a><br /></td></tr>
<tr class="separator:ac5f0a15957842b188826aea98a9cfd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac366495e80b2f51a09f07471006cde28"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac366495e80b2f51a09f07471006cde28"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac366495e80b2f51a09f07471006cde28">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac366495e80b2f51a09f07471006cde28"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object if key does not exist  <a href="#ac366495e80b2f51a09f07471006cde28">More...</a><br /></td></tr>
<tr class="separator:ac366495e80b2f51a09f07471006cde28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c5ca19d22a32054452470669c43bb9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af8c5ca19d22a32054452470669c43bb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af8c5ca19d22a32054452470669c43bb9">insert_iterator</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:af8c5ca19d22a32054452470669c43bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3817060c2bec896a99cb2c236b9c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7f3817060c2bec896a99cb2c236b9c27">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a7f3817060c2bec896a99cb2c236b9c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element into array  <a href="#a7f3817060c2bec896a99cb2c236b9c27">More...</a><br /></td></tr>
<tr class="separator:a7f3817060c2bec896a99cb2c236b9c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5da62116a40a0f86e87f11fdd54e9f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae5da62116a40a0f86e87f11fdd54e9f0">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, <a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:ae5da62116a40a0f86e87f11fdd54e9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element into array  <a href="#ae5da62116a40a0f86e87f11fdd54e9f0">More...</a><br /></td></tr>
<tr class="separator:ae5da62116a40a0f86e87f11fdd54e9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b623200562da188886a385c716d101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a47b623200562da188886a385c716d101">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a47b623200562da188886a385c716d101"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts copies of element into array  <a href="#a47b623200562da188886a385c716d101">More...</a><br /></td></tr>
<tr class="separator:a47b623200562da188886a385c716d101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e1707248a00a2608a304da5ae5c911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a68e1707248a00a2608a304da5ae5c911">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> first, <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> last)</td></tr>
<tr class="memdesc:a68e1707248a00a2608a304da5ae5c911"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts range of elements into array  <a href="#a68e1707248a00a2608a304da5ae5c911">More...</a><br /></td></tr>
<tr class="separator:a68e1707248a00a2608a304da5ae5c911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfee6a3db80431a24c68bfaf038c47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abdfee6a3db80431a24c68bfaf038c47d">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> ilist)</td></tr>
<tr class="memdesc:abdfee6a3db80431a24c68bfaf038c47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts elements from initializer list into array  <a href="#abdfee6a3db80431a24c68bfaf038c47d">More...</a><br /></td></tr>
<tr class="separator:abdfee6a3db80431a24c68bfaf038c47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf55c485c75ddd7bd5f9791e59d3aec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aaf55c485c75ddd7bd5f9791e59d3aec7">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> first, <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> last)</td></tr>
<tr class="memdesc:aaf55c485c75ddd7bd5f9791e59d3aec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts range of elements into object  <a href="#aaf55c485c75ddd7bd5f9791e59d3aec7">More...</a><br /></td></tr>
<tr class="separator:aaf55c485c75ddd7bd5f9791e59d3aec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3819f393e82396782ccc22785575b01d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3819f393e82396782ccc22785575b01d">update</a> (<a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> j, bool merge_objects=false)</td></tr>
<tr class="memdesc:a3819f393e82396782ccc22785575b01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a JSON object from another object, overwriting existing keys  <a href="#a3819f393e82396782ccc22785575b01d">More...</a><br /></td></tr>
<tr class="separator:a3819f393e82396782ccc22785575b01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea2b8cef5e4aba5b92d14e6ebe25936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4ea2b8cef5e4aba5b92d14e6ebe25936">update</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> first, <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> last, bool merge_objects=false)</td></tr>
<tr class="memdesc:a4ea2b8cef5e4aba5b92d14e6ebe25936"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a JSON object from another object, overwriting existing keys  <a href="#a4ea2b8cef5e4aba5b92d14e6ebe25936">More...</a><br /></td></tr>
<tr class="separator:a4ea2b8cef5e4aba5b92d14e6ebe25936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a37aad28d7d89ed2eb04a8a9928552b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2a37aad28d7d89ed2eb04a8a9928552b">swap</a> (<a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; <a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:a2a37aad28d7d89ed2eb04a8a9928552b"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="#a2a37aad28d7d89ed2eb04a8a9928552b">More...</a><br /></td></tr>
<tr class="separator:a2a37aad28d7d89ed2eb04a8a9928552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e32c91d5e641c25c52486341f5a9db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac1e32c91d5e641c25c52486341f5a9db">swap</a> (<a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> &amp;other)</td></tr>
<tr class="memdesc:ac1e32c91d5e641c25c52486341f5a9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="#ac1e32c91d5e641c25c52486341f5a9db">More...</a><br /></td></tr>
<tr class="separator:ac1e32c91d5e641c25c52486341f5a9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9ea6dec87e254de172c2bfeaeef7df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abc9ea6dec87e254de172c2bfeaeef7df">swap</a> (<a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> &amp;other)</td></tr>
<tr class="memdesc:abc9ea6dec87e254de172c2bfeaeef7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="#abc9ea6dec87e254de172c2bfeaeef7df">More...</a><br /></td></tr>
<tr class="separator:abc9ea6dec87e254de172c2bfeaeef7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac8816c033c659ef8b43a5f03d5f553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aeac8816c033c659ef8b43a5f03d5f553">swap</a> (<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &amp;other)</td></tr>
<tr class="memdesc:aeac8816c033c659ef8b43a5f03d5f553"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="#aeac8816c033c659ef8b43a5f03d5f553">More...</a><br /></td></tr>
<tr class="separator:aeac8816c033c659ef8b43a5f03d5f553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3624e1bbc880bd196e3fa4a220554755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3624e1bbc880bd196e3fa4a220554755">swap</a> (<a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;other)</td></tr>
<tr class="memdesc:a3624e1bbc880bd196e3fa4a220554755"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="#a3624e1bbc880bd196e3fa4a220554755">More...</a><br /></td></tr>
<tr class="separator:a3624e1bbc880bd196e3fa4a220554755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa987625005046c81e7748dca1e84a0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa987625005046c81e7748dca1e84a0e3">swap</a> (typename binary_t::container_type &amp;other)</td></tr>
<tr class="memdesc:aa987625005046c81e7748dca1e84a0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="#aa987625005046c81e7748dca1e84a0e3">More...</a><br /></td></tr>
<tr class="separator:aa987625005046c81e7748dca1e84a0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
lexicographical comparison operators</h2></td></tr>
<tr class="memitem:a7dd56e6dab5328365a3c9b9d15f98e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7dd56e6dab5328365a3c9b9d15f98e1b">__pad3__</a>: static bool compares_unordered(<a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> lhs</td></tr>
<tr class="separator:a7dd56e6dab5328365a3c9b9d15f98e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a549b97cc690cd390145249335d3768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3a549b97cc690cd390145249335d3768">rhs</a></td></tr>
<tr class="separator:a3a549b97cc690cd390145249335d3768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54aba2f4314135e3ccf511fb17ca45a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a54aba2f4314135e3ccf511fb17ca45a5">inverse</a></td></tr>
<tr class="separator:a54aba2f4314135e3ccf511fb17ca45a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
binary serialization/deserialization support</h2></td></tr>
<tr class="memitem:a9bea2fdeaff0956562cafd89fdba9139"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9bea2fdeaff0956562cafd89fdba9139">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a9bea2fdeaff0956562cafd89fdba9139"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <a href="#a9bea2fdeaff0956562cafd89fdba9139">More...</a><br /></td></tr>
<tr class="separator:a9bea2fdeaff0956562cafd89fdba9139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706ccab0e47bd75cd36911db84451cd1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a706ccab0e47bd75cd36911db84451cd1">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:a706ccab0e47bd75cd36911db84451cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <a href="#a706ccab0e47bd75cd36911db84451cd1">More...</a><br /></td></tr>
<tr class="separator:a706ccab0e47bd75cd36911db84451cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31f5ee23264fb21bd31e16bc27adab2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af31f5ee23264fb21bd31e16bc27adab2">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:af31f5ee23264fb21bd31e16bc27adab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <a href="#af31f5ee23264fb21bd31e16bc27adab2">More...</a><br /></td></tr>
<tr class="separator:af31f5ee23264fb21bd31e16bc27adab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad317526e90c898957af9ce1c8c011caa"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad317526e90c898957af9ce1c8c011caa">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:ad317526e90c898957af9ce1c8c011caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <a href="#ad317526e90c898957af9ce1c8c011caa">More...</a><br /></td></tr>
<tr class="separator:ad317526e90c898957af9ce1c8c011caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46fdac62559d4c38e623d99ad7064e9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af46fdac62559d4c38e623d99ad7064e9">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:af46fdac62559d4c38e623d99ad7064e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <a href="#af46fdac62559d4c38e623d99ad7064e9">More...</a><br /></td></tr>
<tr class="separator:af46fdac62559d4c38e623d99ad7064e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51da13ff4e850d4ad1cf23ce4f3b9e4a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a51da13ff4e850d4ad1cf23ce4f3b9e4a">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:a51da13ff4e850d4ad1cf23ce4f3b9e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <a href="#a51da13ff4e850d4ad1cf23ce4f3b9e4a">More...</a><br /></td></tr>
<tr class="separator:a51da13ff4e850d4ad1cf23ce4f3b9e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6d27aedd29bed0cd145638f4f32fdc"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afa6d27aedd29bed0cd145638f4f32fdc">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:afa6d27aedd29bed0cd145638f4f32fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <a href="#afa6d27aedd29bed0cd145638f4f32fdc">More...</a><br /></td></tr>
<tr class="separator:afa6d27aedd29bed0cd145638f4f32fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3d71f1dcfea24465d364b815d11445"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ada3d71f1dcfea24465d364b815d11445">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:ada3d71f1dcfea24465d364b815d11445"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <a href="#ada3d71f1dcfea24465d364b815d11445">More...</a><br /></td></tr>
<tr class="separator:ada3d71f1dcfea24465d364b815d11445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b6c6cc3ba1b49af628fe0ec8c73b77"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab8b6c6cc3ba1b49af628fe0ec8c73b77">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:ab8b6c6cc3ba1b49af628fe0ec8c73b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <a href="#ab8b6c6cc3ba1b49af628fe0ec8c73b77">More...</a><br /></td></tr>
<tr class="separator:ab8b6c6cc3ba1b49af628fe0ec8c73b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af410354f1c82a34f388e438cc47c31f8"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af410354f1c82a34f388e438cc47c31f8">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:af410354f1c82a34f388e438cc47c31f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <a href="#af410354f1c82a34f388e438cc47c31f8">More...</a><br /></td></tr>
<tr class="separator:af410354f1c82a34f388e438cc47c31f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2736658c256401394059599f97139ee9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2736658c256401394059599f97139ee9">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a2736658c256401394059599f97139ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <a href="#a2736658c256401394059599f97139ee9">More...</a><br /></td></tr>
<tr class="separator:a2736658c256401394059599f97139ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa9828fcbe4e33c9a036834564f7dbd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1fa9828fcbe4e33c9a036834564f7dbd">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a1fa9828fcbe4e33c9a036834564f7dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <a href="#a1fa9828fcbe4e33c9a036834564f7dbd">More...</a><br /></td></tr>
<tr class="separator:a1fa9828fcbe4e33c9a036834564f7dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0945ada0a9b5afd776b2d6ea2c048a5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae0945ada0a9b5afd776b2d6ea2c048a5">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:ae0945ada0a9b5afd776b2d6ea2c048a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <a href="#ae0945ada0a9b5afd776b2d6ea2c048a5">More...</a><br /></td></tr>
<tr class="separator:ae0945ada0a9b5afd776b2d6ea2c048a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd718b745034da1f4eea4c69f45cebda"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afd718b745034da1f4eea4c69f45cebda">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:afd718b745034da1f4eea4c69f45cebda"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <a href="#afd718b745034da1f4eea4c69f45cebda">More...</a><br /></td></tr>
<tr class="separator:afd718b745034da1f4eea4c69f45cebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71794547dde3dd67e444aa45131ca861"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a71794547dde3dd67e444aa45131ca861">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:a71794547dde3dd67e444aa45131ca861"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <a href="#a71794547dde3dd67e444aa45131ca861">More...</a><br /></td></tr>
<tr class="separator:a71794547dde3dd67e444aa45131ca861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc3c67eaf6e9b22c8b446f9695249e9"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a5bc3c67eaf6e9b22c8b446f9695249e9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5bc3c67eaf6e9b22c8b446f9695249e9">from_cbor</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="memdesc:a5bc3c67eaf6e9b22c8b446f9695249e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in CBOR format  <a href="#a5bc3c67eaf6e9b22c8b446f9695249e9">More...</a><br /></td></tr>
<tr class="separator:a5bc3c67eaf6e9b22c8b446f9695249e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ab03513b96f5a864bf623aeb70f122"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a08ab03513b96f5a864bf623aeb70f122"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a08ab03513b96f5a864bf623aeb70f122">from_cbor</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="memdesc:a08ab03513b96f5a864bf623aeb70f122"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in CBOR format  <a href="#a08ab03513b96f5a864bf623aeb70f122">More...</a><br /></td></tr>
<tr class="separator:a08ab03513b96f5a864bf623aeb70f122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a8b31922ebb7a637e723ac7873fa4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89a8b31922ebb7a637e723ac7873fa4a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a89a8b31922ebb7a637e723ac7873fa4a">from_cbor</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="separator:a89a8b31922ebb7a637e723ac7873fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8680ff0784c185b6898839a98de88486"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8680ff0784c185b6898839a98de88486">from_cbor</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="separator:a8680ff0784c185b6898839a98de88486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c025488572f913ca5529a2ef62d066"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:ab0c025488572f913ca5529a2ef62d066"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab0c025488572f913ca5529a2ef62d066">from_msgpack</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:ab0c025488572f913ca5529a2ef62d066"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in MessagePack format  <a href="#ab0c025488572f913ca5529a2ef62d066">More...</a><br /></td></tr>
<tr class="separator:ab0c025488572f913ca5529a2ef62d066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d84b161b2d93f9b2b3ac8d68afeb96"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:af7d84b161b2d93f9b2b3ac8d68afeb96"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af7d84b161b2d93f9b2b3ac8d68afeb96">from_msgpack</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:af7d84b161b2d93f9b2b3ac8d68afeb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in MessagePack format  <a href="#af7d84b161b2d93f9b2b3ac8d68afeb96">More...</a><br /></td></tr>
<tr class="separator:af7d84b161b2d93f9b2b3ac8d68afeb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a721efc291300b45ac410ab75b8478b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a721efc291300b45ac410ab75b8478b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2a721efc291300b45ac410ab75b8478b">from_msgpack</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a2a721efc291300b45ac410ab75b8478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c5fdb783d4f97a9062ab41809ec0c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae8c5fdb783d4f97a9062ab41809ec0c6">from_msgpack</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:ae8c5fdb783d4f97a9062ab41809ec0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4588941095d03624ada4f0023d93944a"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a4588941095d03624ada4f0023d93944a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4588941095d03624ada4f0023d93944a">from_ubjson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a4588941095d03624ada4f0023d93944a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in UBJSON format  <a href="#a4588941095d03624ada4f0023d93944a">More...</a><br /></td></tr>
<tr class="separator:a4588941095d03624ada4f0023d93944a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd7470a3be83b27cf162c0261e6b63d"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a5dd7470a3be83b27cf162c0261e6b63d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5dd7470a3be83b27cf162c0261e6b63d">from_ubjson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a5dd7470a3be83b27cf162c0261e6b63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in UBJSON format  <a href="#a5dd7470a3be83b27cf162c0261e6b63d">More...</a><br /></td></tr>
<tr class="separator:a5dd7470a3be83b27cf162c0261e6b63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa375318d8ef6052fd4d606d596d9c424"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa375318d8ef6052fd4d606d596d9c424"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa375318d8ef6052fd4d606d596d9c424">from_ubjson</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:aa375318d8ef6052fd4d606d596d9c424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad915ce03b8ec612764bb67d09e658a0d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad915ce03b8ec612764bb67d09e658a0d">from_ubjson</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:ad915ce03b8ec612764bb67d09e658a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59327f708c0555e2928487bcddf71293"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a59327f708c0555e2928487bcddf71293"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a59327f708c0555e2928487bcddf71293">from_bjdata</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a59327f708c0555e2928487bcddf71293"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BJData format  <a href="#a59327f708c0555e2928487bcddf71293">More...</a><br /></td></tr>
<tr class="separator:a59327f708c0555e2928487bcddf71293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf7ae6f9b2fee171484c5ef54f08d1e"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:accf7ae6f9b2fee171484c5ef54f08d1e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#accf7ae6f9b2fee171484c5ef54f08d1e">from_bjdata</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:accf7ae6f9b2fee171484c5ef54f08d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BJData format  <a href="#accf7ae6f9b2fee171484c5ef54f08d1e">More...</a><br /></td></tr>
<tr class="separator:accf7ae6f9b2fee171484c5ef54f08d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0dfca88b11ea59a2568707767622d8"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a4b0dfca88b11ea59a2568707767622d8"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4b0dfca88b11ea59a2568707767622d8">from_bson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a4b0dfca88b11ea59a2568707767622d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BSON format  <a href="#a4b0dfca88b11ea59a2568707767622d8">More...</a><br /></td></tr>
<tr class="separator:a4b0dfca88b11ea59a2568707767622d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2513159e8df9a81bf03ed34e1147b42e"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a2513159e8df9a81bf03ed34e1147b42e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2513159e8df9a81bf03ed34e1147b42e">from_bson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a2513159e8df9a81bf03ed34e1147b42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BSON format  <a href="#a2513159e8df9a81bf03ed34e1147b42e">More...</a><br /></td></tr>
<tr class="separator:a2513159e8df9a81bf03ed34e1147b42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e33baaab9ab497f0fe6b797134c9524"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e33baaab9ab497f0fe6b797134c9524"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7e33baaab9ab497f0fe6b797134c9524">from_bson</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a7e33baaab9ab497f0fe6b797134c9524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9761fba9571455a96309f7ba647757"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aed9761fba9571455a96309f7ba647757">from_bson</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:aed9761fba9571455a96309f7ba647757"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
JSON Pointer functions</h2></td></tr>
<tr class="memitem:a274307158c76b820701077dd471cc75b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a274307158c76b820701077dd471cc75b">operator[]</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr)</td></tr>
<tr class="memdesc:a274307158c76b820701077dd471cc75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="#a274307158c76b820701077dd471cc75b">More...</a><br /></td></tr>
<tr class="separator:a274307158c76b820701077dd471cc75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ef76e450ec1bf467c72535becc0be6"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af9ef76e450ec1bf467c72535becc0be6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af9ef76e450ec1bf467c72535becc0be6">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">basic_json::json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">basic_json::string_t</a> &gt;) <a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> operator[](const</td></tr>
<tr class="separator:af9ef76e450ec1bf467c72535becc0be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aedef6230f66b1271d71a6f77e7fed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6aedef6230f66b1271d71a6f77e7fed3">operator[]</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:a6aedef6230f66b1271d71a6f77e7fed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="#a6aedef6230f66b1271d71a6f77e7fed3">More...</a><br /></td></tr>
<tr class="separator:a6aedef6230f66b1271d71a6f77e7fed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174114f78e24693f61dae1840af50979"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a174114f78e24693f61dae1840af50979"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a174114f78e24693f61dae1840af50979">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">basic_json::json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">basic_json::string_t</a> &gt;) const _reference operator[](const</td></tr>
<tr class="memdesc:a174114f78e24693f61dae1840af50979"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="#a174114f78e24693f61dae1840af50979">More...</a><br /></td></tr>
<tr class="separator:a174114f78e24693f61dae1840af50979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c01c57845336ed472ccc68be13c364c"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2c01c57845336ed472ccc68be13c364c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2c01c57845336ed472ccc68be13c364c">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">basic_json::json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">basic_json::string_t</a> &gt;) <a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html#a899e4623fe377af5c9ad14c40c64280c">at</a>(const</td></tr>
<tr class="separator:a2c01c57845336ed472ccc68be13c364c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3a35d456e3250640a90c6f7a7fd555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5a3a35d456e3250640a90c6f7a7fd555">at</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:a5a3a35d456e3250640a90c6f7a7fd555"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="#a5a3a35d456e3250640a90c6f7a7fd555">More...</a><br /></td></tr>
<tr class="separator:a5a3a35d456e3250640a90c6f7a7fd555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
JSON Patch functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp440f929bef0e9348b145a71c542fb0c3"></a>return flattened JSON value</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/flatten/">https://json.nlohmann.me/api/basic_json/flatten/</a> unflatten a previously flattened JSON <a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef" title="access specified object element with default value ">value</a> </dd>
<dd>
<a href="https://json.nlohmann.me/api/basic_json/unflatten/">https://json.nlohmann.me/api/basic_json/unflatten/</a> </dd></dl>
</td></tr>
<tr class="memitem:a699ef418df577e75f28dfce6b04d6c2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a699ef418df577e75f28dfce6b04d6c2f">diff</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;source, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;target, const std::string &amp;path=&quot;&quot;)</td></tr>
<tr class="memdesc:a699ef418df577e75f28dfce6b04d6c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a diff as a JSON patch  <a href="#a699ef418df577e75f28dfce6b04d6c2f">More...</a><br /></td></tr>
<tr class="separator:a699ef418df577e75f28dfce6b04d6c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a004c0a2fa5be84b260ecc98ab5d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a145a004c0a2fa5be84b260ecc98ab5d9">patch</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;json_patch) const</td></tr>
<tr class="memdesc:a145a004c0a2fa5be84b260ecc98ab5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a JSON patch to a copy of the current object  <a href="#a145a004c0a2fa5be84b260ecc98ab5d9">More...</a><br /></td></tr>
<tr class="separator:a145a004c0a2fa5be84b260ecc98ab5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
JSON Merge Patch functions</h2></td></tr>
<tr class="memitem:a8676ac2433fe299b8d420f00a0741395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8676ac2433fe299b8d420f00a0741395">merge_patch</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;apply_patch)</td></tr>
<tr class="memdesc:a8676ac2433fe299b8d420f00a0741395"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a JSON Merge Patch  <a href="#a8676ac2433fe299b8d420f00a0741395">More...</a><br /></td></tr>
<tr class="separator:a8676ac2433fe299b8d420f00a0741395"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass = void&gt;<br />
class basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;</h3>

<p>namespace for Niels Lohmann </p>
<p>a class to store JSON values </p><dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/">https://json.nlohmann.me/api/basic_json/</a></dd>
<dd>
<a href="https://github.com/nlohmann">https://github.com/nlohmann</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0</dd></dl>
<p><br />
a class to store JSON values</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l03397">3397</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a83f845db2d54cedad97279bad70aea52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f845db2d54cedad97279bad70aea52">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a> =  AllocatorType&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the allocator type </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19435">19435</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6b282cae56b331d222c7da4b05eab5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b282cae56b331d222c7da4b05eab5e8">&#9670;&nbsp;</a></span>array_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> =  ArrayType&lt;<a class="el" href="classbasic__json.html">basic_json</a>, AllocatorType&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/array_t/">https://json.nlohmann.me/api/basic_json/array_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19559">19559</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aeb9caf9b95ef9e29b440dd1f0c822f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9caf9b95ef9e29b440dd1f0c822f74">&#9670;&nbsp;</a></span>basic_json_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a> =  <a class="el" href="json_8hpp.html#a80b7254e63f199a1f656f07ae551f632">NLOHMANN_BASIC_JSON_TPL</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>workaround type for MSVC </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19338">19338</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a70b96a2315625383ea8d6dbc466978a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b96a2315625383ea8d6dbc466978a9">&#9670;&nbsp;</a></span>binary_reader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a70b96a2315625383ea8d6dbc466978a9">binary_reader</a> =  ::nlohmann::detail::binary_reader&lt;<a class="el" href="classbasic__json.html">basic_json</a>, InputType&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19371">19371</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4c1b5ea434b48cf31097617bb1c1ca1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1b5ea434b48cf31097617bb1c1ca1e">&#9670;&nbsp;</a></span>binary_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> =  nlohmann::byte_container_with_subtype&lt;<a class="el" href="class_binary_type.html">BinaryType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a packed binary type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary_t/">https://json.nlohmann.me/api/basic_json/binary_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19583">19583</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aed0261c797ae5126681e4a68d1e8eacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0261c797ae5126681e4a68d1e8eacc">&#9670;&nbsp;</a></span>binary_writer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename CharType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#aed0261c797ae5126681e4a68d1e8eacc">binary_writer</a> =  ::nlohmann::detail::binary_writer&lt;<a class="el" href="classbasic__json.html">basic_json</a>, CharType&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19372">19372</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a9301890c48e9b957edc07f9eb767bd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9301890c48e9b957edc07f9eb767bd10">&#9670;&nbsp;</a></span>boolean_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> =  BooleanType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a boolean </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/boolean_t/">https://json.nlohmann.me/api/basic_json/boolean_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19567">19567</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a067b4f0e63e55055272fec0a26b5b991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067b4f0e63e55055272fec0a26b5b991">&#9670;&nbsp;</a></span>cbor_tag_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> =  <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">detail::cbor_tag_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how to treat CBOR tags </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19386">19386</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a1f5af3d9d06d43b91fefe1767794b1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5af3d9d06d43b91fefe1767794b1e8">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> =  <a class="el" href="classbasic__json.html#a397adf6b027ef3c202ec3aa6f6c1f149">iter_impl</a>&lt;const <a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a const iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19445">19445</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2862fa42527f5c14d9f737411e0facd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2862fa42527f5c14d9f737411e0facd4">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a2862fa42527f5c14d9f737411e0facd4">const_pointer</a> =  typename std::allocator_traits&lt;<a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a>&gt;::<a class="el" href="classbasic__json.html#a2862fa42527f5c14d9f737411e0facd4">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element const pointer </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19440">19440</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a31370bb451b78198d42c86dd31955deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31370bb451b78198d42c86dd31955deb">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> =  const <a class="el" href="classbasic__json.html#a0d9e6a7acee2992e310ea21a7b59c67a">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element const reference </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19427">19427</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a240f61567d8acffe831532f4f9b379cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240f61567d8acffe831532f4f9b379cb">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a240f61567d8acffe831532f4f9b379cb">const_reverse_iterator</a> =  <a class="el" href="classbasic__json.html#a40b525218bf76ba0c3d75bb4c1e30a3a">json_reverse_iterator</a>&lt;typename <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">basic_json::const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a const reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19449">19449</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a991d005e7f648cbf37bb36daf85183ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991d005e7f648cbf37bb36daf85183ca">&#9670;&nbsp;</a></span>default_object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a991d005e7f648cbf37bb36daf85183ca">default_object_comparator_t</a> =  std::less&lt;StringType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default object key comparator type The actual object key comparator type (<a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a>) may be different. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/default_object_comparator_t/">https://json.nlohmann.me/api/basic_json/default_object_comparator_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19546">19546</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae45e8f7ce7c3e62035cd097a39910399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45e8f7ce7c3e62035cd097a39910399">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ae45e8f7ce7c3e62035cd097a39910399">difference_type</a> =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type to represent differences between iterators </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19430">19430</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2ebde9badb4f1b4cf6517f6b8e302d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebde9badb4f1b4cf6517f6b8e302d0d">&#9670;&nbsp;</a></span>error_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a> =  <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">detail::error_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how to treat decoding errors </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19384">19384</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4ed57fa411e69ae5741bc2f333a967c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed57fa411e69ae5741bc2f333a967c9">&#9670;&nbsp;</a></span>exception</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a4ed57fa411e69ae5741bc2f333a967c9">exception</a> =  <a class="el" href="classdetail_1_1exception.html">detail::exception</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19402">19402</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a21f7c93f896d302ed0b62d983aac53c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f7c93f896d302ed0b62d983aac53c0">&#9670;&nbsp;</a></span>initializer_list_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> =  std::initializer_list&lt;<a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper type for initializer lists of <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> values </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19388">19388</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a143e447269d8beb1d02400093eccd018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143e447269d8beb1d02400093eccd018">&#9670;&nbsp;</a></span>input_format_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> =  <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">detail::input_format_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19390">19390</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a959fc432c8d609d2bebb998fb6b6a1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959fc432c8d609d2bebb998fb6b6a1a7">&#9670;&nbsp;</a></span>internal_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a959fc432c8d609d2bebb998fb6b6a1a7">internal_iterator</a> =  ::nlohmann::detail::internal_iterator&lt;BasicJsonType&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19360">19360</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a34b69b2a91df080e00cc8f36c342bb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b69b2a91df080e00cc8f36c342bb6b">&#9670;&nbsp;</a></span>invalid_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a34b69b2a91df080e00cc8f36c342bb6b">invalid_iterator</a> =  <a class="el" href="classdetail_1_1invalid__iterator.html">detail::invalid_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19404">19404</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a10771c460900f2f8cac0841d48ab3e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10771c460900f2f8cac0841d48ab3e30">&#9670;&nbsp;</a></span>is_comparable_with_object_key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a10771c460900f2f8cac0841d48ab3e30">is_comparable_with_object_key</a> =  <a class="el" href="structdetail_1_1is__comparable.html">detail::is_comparable</a> &lt; <a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a>, const typename object_t::key_type&amp;, KeyType &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21429">21429</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a397adf6b027ef3c202ec3aa6f6c1f149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397adf6b027ef3c202ec3aa6f6c1f149">&#9670;&nbsp;</a></span>iter_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a397adf6b027ef3c202ec3aa6f6c1f149">iter_impl</a> =  ::nlohmann::detail::iter_impl&lt;BasicJsonType&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19362">19362</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0b10619e48d72b3257ddd92bb5e3cab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b10619e48d72b3257ddd92bb5e3cab2">&#9670;&nbsp;</a></span>iteration_proxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a0b10619e48d72b3257ddd92bb5e3cab2">iteration_proxy</a> =  ::nlohmann::detail::iteration_proxy&lt;Iterator&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19364">19364</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae206a491161d043f8efaa1330f1ccf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae206a491161d043f8efaa1330f1ccf97">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> =  <a class="el" href="classbasic__json.html#a397adf6b027ef3c202ec3aa6f6c1f149">iter_impl</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19443">19443</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2539b2d00d469e0ff753617abf22e6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2539b2d00d469e0ff753617abf22e6ce">&#9670;&nbsp;</a></span>json_base_class_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a2539b2d00d469e0ff753617abf22e6ce">json_base_class_t</a> =  ::nlohmann::detail::json_base_class&lt;CustomBaseClass&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19339">19339</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="afe66720a34c11920f359394a4430a16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe66720a34c11920f359394a4430a16e">&#9670;&nbsp;</a></span>json_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> =  ::nlohmann::json_pointer&lt;StringType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JSON Pointer, see nlohmann::json_pointer. </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19380">19380</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a40b525218bf76ba0c3d75bb4c1e30a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b525218bf76ba0c3d75bb4c1e30a3a">&#9670;&nbsp;</a></span>json_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a40b525218bf76ba0c3d75bb4c1e30a3a">json_reverse_iterator</a> =  ::nlohmann::detail::json_reverse_iterator&lt;Base&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19365">19365</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="acefb05e1022be791038db86c9963cec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefb05e1022be791038db86c9963cec7">&#9670;&nbsp;</a></span>json_sax_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#acefb05e1022be791038db86c9963cec7">json_sax_t</a> =  <a class="el" href="structjson__sax.html">json_sax</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SAX interface type, see nlohmann::json_sax. </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19392">19392</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab75fd791f0b8fca724e5ed70b4956414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75fd791f0b8fca724e5ed70b4956414">&#9670;&nbsp;</a></span>json_serializer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename SFINAE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer</a> =  JSONSerializer&lt;T, SFINAE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19382">19382</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a80a229dbc84c1334171ce9c49c873c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a229dbc84c1334171ce9c49c873c56">&#9670;&nbsp;</a></span>number_float_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> =  NumberFloatType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (floating-point) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_float_t/">https://json.nlohmann.me/api/basic_json/number_float_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19579">19579</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aba48b0bdee31228a4e19b7c040b6d2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba48b0bdee31228a4e19b7c040b6d2a5">&#9670;&nbsp;</a></span>number_integer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> =  NumberIntegerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (integer) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_integer_t/">https://json.nlohmann.me/api/basic_json/number_integer_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19571">19571</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae8505b599e706768a1e0bd6718cc7117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8505b599e706768a1e0bd6718cc7117">&#9670;&nbsp;</a></span>number_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> =  NumberUnsignedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (unsigned) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_unsigned_t/">https://json.nlohmann.me/api/basic_json/number_unsigned_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19575">19575</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af12040e0663db54840d73d363979643a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12040e0663db54840d73d363979643a">&#9670;&nbsp;</a></span>object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a> =  <a class="el" href="namespacedetail.html#acf3e5af512080ec5b71496dde9e0651c">detail::actual_object_comparator_t</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>object key comparator type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object_comparator_t/">https://json.nlohmann.me/api/basic_json/object_comparator_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19587">19587</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac90f70623dc1ad761ea1c5013b2fee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90f70623dc1ad761ea1c5013b2fee47">&#9670;&nbsp;</a></span>object_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> =  ObjectType&lt;StringType, <a class="el" href="classbasic__json.html">basic_json</a>, <a class="el" href="classbasic__json.html#a991d005e7f648cbf37bb36daf85183ca">default_object_comparator_t</a>, AllocatorType&lt;std::pair&lt;const StringType, <a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object_t/">https://json.nlohmann.me/api/basic_json/object_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19555">19555</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="adb2d18607e0835c4695f53996b181379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2d18607e0835c4695f53996b181379">&#9670;&nbsp;</a></span>other_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#adb2d18607e0835c4695f53996b181379">other_error</a> =  <a class="el" href="classdetail_1_1other__error.html">detail::other_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19407">19407</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa45e2d88a6cf9236c1f45a1fad18442d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45e2d88a6cf9236c1f45a1fad18442d">&#9670;&nbsp;</a></span>out_of_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#aa45e2d88a6cf9236c1f45a1fad18442d">out_of_range</a> =  <a class="el" href="classdetail_1_1out__of__range.html">detail::out_of_range</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19406">19406</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3b84a1efe204d891a06767be452fdf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b84a1efe204d891a06767be452fdf60">&#9670;&nbsp;</a></span>output_adapter_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename CharType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a3b84a1efe204d891a06767be452fdf60">output_adapter_t</a> =  ::nlohmann::detail::output_adapter_t&lt;CharType&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19368">19368</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0fe1802a6a2de032f3c4e4f0f555ae10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe1802a6a2de032f3c4e4f0f555ae10">&#9670;&nbsp;</a></span>parse_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a0fe1802a6a2de032f3c4e4f0f555ae10">parse_error</a> =  <a class="el" href="classdetail_1_1parse__error.html">detail::parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19403">19403</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a53b6bf8ee18c48f4609c8bdd4bb95107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b6bf8ee18c48f4609c8bdd4bb95107">&#9670;&nbsp;</a></span>parse_event_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="namespacedetail.html#a47b1bb0bbd3596589ed9187059c312ef">parse_event_t</a> =  <a class="el" href="namespacedetail.html#a47b1bb0bbd3596589ed9187059c312ef">detail::parse_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parser event types </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/parse_event_t/">https://json.nlohmann.me/api/basic_json/parse_event_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20016">20016</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a50644d655c9283aaf0e2a0f3a5428867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50644d655c9283aaf0e2a0f3a5428867">&#9670;&nbsp;</a></span>parser_callback_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a50644d655c9283aaf0e2a0f3a5428867">parser_callback_t</a> =  <a class="el" href="namespacedetail.html#a20a6b9b232b9f47ce057fe5cc5bbf511">detail::parser_callback_t</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>per-element parser callback type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/parser_callback_t/">https://json.nlohmann.me/api/basic_json/parser_callback_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20020">20020</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a84279673ab13fb6360cf17173a29a1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84279673ab13fb6360cf17173a29a1f1">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a84279673ab13fb6360cf17173a29a1f1">pointer</a> =  typename std::allocator_traits&lt;<a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a>&gt;::<a class="el" href="classbasic__json.html#a84279673ab13fb6360cf17173a29a1f1">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element pointer </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19438">19438</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a632f199bc4b79371487f529cfdcc267c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632f199bc4b79371487f529cfdcc267c">&#9670;&nbsp;</a></span>primitive_iterator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a632f199bc4b79371487f529cfdcc267c">primitive_iterator_t</a> =  ::nlohmann::detail::primitive_iterator_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19358">19358</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6ca7bfb35987ce7cb8d27447cda5b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca7bfb35987ce7cb8d27447cda5b80a">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> =  <a class="el" href="classbasic__json.html#a0d9e6a7acee2992e310ea21a7b59c67a">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element reference </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19425">19425</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aedc059cdae078322bb0d434b2127d1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc059cdae078322bb0d434b2127d1cf">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#aedc059cdae078322bb0d434b2127d1cf">reverse_iterator</a> =  <a class="el" href="classbasic__json.html#a40b525218bf76ba0c3d75bb4c1e30a3a">json_reverse_iterator</a>&lt;typename <a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">basic_json::iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19447">19447</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2c086af43cf06b1b7118f5351cab3ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c086af43cf06b1b7118f5351cab3ec9">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type to represent container sizes </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19432">19432</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac8c9cde32146e6c343e1960aefc11fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c9cde32146e6c343e1960aefc11fba">&#9670;&nbsp;</a></span>string_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> =  StringType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/string_t/">https://json.nlohmann.me/api/basic_json/string_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19563">19563</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2c52f112e54d1be294055ea9186a1c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c52f112e54d1be294055ea9186a1c35">&#9670;&nbsp;</a></span>type_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a2c52f112e54d1be294055ea9186a1c35">type_error</a> =  <a class="el" href="classdetail_1_1type__error.html">detail::type_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19405">19405</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a96d2f51d8300e987422052ff3f4a4064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d2f51d8300e987422052ff3f4a4064">&#9670;&nbsp;</a></span>value_return_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a96d2f51d8300e987422052ff3f4a4064">value_return_type</a> =  std::conditional &lt; <a class="el" href="namespacedetail.html#a9d99cdff6fa6a48145e5f7209d60db5a">detail::is_c_string_uncvref</a>&lt;ValueType&gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>, <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>, typename std::decay&lt;ValueType&gt;::<a class="el" href="classstd_1_1conditional_1_1type.html">type</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21434">21434</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a966e900415e66f3ab60f7b5ef52fd63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966e900415e66f3ab60f7b5ef52fd63b">&#9670;&nbsp;</a></span>value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> =  <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19378">19378</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0d9e6a7acee2992e310ea21a7b59c67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9e6a7acee2992e310ea21a7b59c67a">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a0d9e6a7acee2992e310ea21a7b59c67a">value_type</a> =  <a class="el" href="classbasic__json.html">basic_json</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of elements in a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19422">19422</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae2d5bc42270881ed3e219e8b1456fec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d5bc42270881ed3e219e8b1456fec5">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an empty value with a given type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20033">20033</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5b1fab9ded0a2a182837bd66c0e5189e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1fab9ded0a2a182837bd66c0e5189e">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a null object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20041">20041</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7a631fcf93bb88189959be86a3c914f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a631fcf93bb88189959be86a3c914f9">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, detail::enable_if_t&lt; !detail::is_basic_json&lt; U &gt;::value &amp;&amp;detail::is_compatible_type&lt; basic_json_t, U &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">CompatibleType &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from compatible types </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20053">20053</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aeaf10402e79a1acce9a74f5a9654d403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf10402e79a1acce9a74f5a9654d403">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;!std::is_same&lt; basic_json, BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an existing one </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20067">20067</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa911d47d3c99184a301bf4fd304199b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa911d47d3c99184a301bf4fd304199b2">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>type_deduction</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>manual_type</em> = <code><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a container (array or object) from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20120">20120</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7b6f0605b09a002567fd18a289cef31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6f0605b09a002567fd18a289cef31b">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct an array with count copies of given value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20235">20235</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af97b4fcd01509076c8a7b32ec1a10aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97b4fcd01509076c8a7b32ec1a10aec">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;::value||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct a JSON container given an iterator range </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20247">20247</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab6712795591ec744415b50bc01d768ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6712795591ec744415b50bc01d768ed">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename JsonRef , detail::enable_if_t&lt; detail::conjunction&lt; detail::is_json_ref&lt; JsonRef &gt;, std::is_same&lt; typename JsonRef::value_type, basic_json &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const JsonRef &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20357">20357</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af15244e1249b6e7282127d460b5b2e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15244e1249b6e7282127d460b5b2e3e">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20361">20361</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae18629aae4bd76e6f7920cf4e7b4dd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18629aae4bd76e6f7920cf4e7b4dd60">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20430">20430</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a9f3bcb6dc54f447ad95085715104494e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3bcb6dc54f447ad95085715104494e">&#9670;&nbsp;</a></span>~basic_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::~<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/~basic_json/">https://json.nlohmann.me/api/basic_json/~basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20470">20470</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="acdc878691d825f4376b4e177b2818b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc878691d825f4376b4e177b2818b59">&#9670;&nbsp;</a></span>~data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::~<a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23437">23437</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac736994a792cb8460a30a3f4dd86fd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac736994a792cb8460a30a3f4dd86fd78">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create an array from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/array/">https://json.nlohmann.me/api/basic_json/array/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20220">20220</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a54ffa8ef2d9d5971619fdac9012ae8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ffa8ef2d9d5971619fdac9012ae8dd">&#9670;&nbsp;</a></span>assert_invariant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::assert_invariant </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_parents</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks the class invariants </p>
<p>This function asserts the class invariants. It needs to be called at the end of every constructor to make sure that created objects respect the invariant. Furthermore, it has to be called each time the type of a JSON value is changed, because the invariant expresses a relationship between <em>m_type</em> and <em>m_value</em>.</p>
<p>Furthermore, the parent relation is checked for arrays and objects: If <em>check_parents</em> true and the value is an array or object, then the container's elements must have the current value as parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">check_parents</td><td>whether the parent relation should be checked. The value is true by default and should only be set to false during destruction of objects when the invariant does not need to hold. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19900">19900</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a899e4623fe377af5c9ad14c40c64280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899e4623fe377af5c9ad14c40c64280c">&#9670;&nbsp;</a></span>at() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21155">21155</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af076d8a80f4263cf821da2033d5773b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af076d8a80f4263cf821da2033d5773b6">&#9670;&nbsp;</a></span>at() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21178">21178</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="accafaaf23f60bb245ddb1fa0972b33a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accafaaf23f60bb245ddb1fa0972b33a3">&#9670;&nbsp;</a></span>at() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21201">21201</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4cd9ba2f2164d9cee83b07f76d40843f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd9ba2f2164d9cee83b07f76d40843f">&#9670;&nbsp;</a></span>at() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21221">21221</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aba9a21714e81e98fc5786a2339ea1665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9a21714e81e98fc5786a2339ea1665">&#9670;&nbsp;</a></span>at() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21239">21239</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7ae6267ca4bd85e25f61dc5ba30204da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae6267ca4bd85e25f61dc5ba30204da">&#9670;&nbsp;</a></span>at() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21259">21259</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5a3a35d456e3250640a90c6f7a7fd555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3a35d456e3250640a90c6f7a7fd555">&#9670;&nbsp;</a></span>at() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23885">23885</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0d93dc1dbdf67a6ee3a5cf1d2439ca77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d93dc1dbdf67a6ee3a5cf1d2439ca77">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/back/">https://json.nlohmann.me/api/basic_json/back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21625">21625</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a41eee3066cd1ebfea746f9f07fd03f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41eee3066cd1ebfea746f9f07fd03f6f">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/back/">https://json.nlohmann.me/api/basic_json/back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21634">21634</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a743ac3bcbc4b0f7897244d4cea387eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743ac3bcbc4b0f7897244d4cea387eee">&#9670;&nbsp;</a></span>binary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20176">20176</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a45e65e73d9ecf780537d632372fa2c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e65e73d9ecf780537d632372fa2c51">&#9670;&nbsp;</a></span>binary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename binary_t::subtype_type&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20187">20187</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5af2196a9acde33f742ef054e7c2109c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af2196a9acde33f742ef054e7c2109c">&#9670;&nbsp;</a></span>binary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20198">20198</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac00a2a38929ce21eae65f9dd09b03ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00a2a38929ce21eae65f9dd09b03ce3">&#9670;&nbsp;</a></span>binary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename binary_t::subtype_type&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20209">20209</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="afd5ea67fe1a4778be5189423e2545d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5ea67fe1a4778be5189423e2545d7a">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21947">21947</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7053bdd8e9ee2fcb0ca9c54ec85f1297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7053bdd8e9ee2fcb0ca9c54ec85f1297">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21956">21956</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac4c37affef3aa8c79cab9f3bfa2cb5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c37affef3aa8c79cab9f3bfa2cb5e1">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object given a JSON pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21963">21963</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad1e1eff03a320299e6a8639a7579ca46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e1eff03a320299e6a8639a7579ca46">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of occurrences of a key in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/count/">https://json.nlohmann.me/api/basic_json/count/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21929">21929</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a1ba1cd73d36a2cd58a9da7021b0f7317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba1cd73d36a2cd58a9da7021b0f7317">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::count </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of occurrences of a key in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/count/">https://json.nlohmann.me/api/basic_json/count/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21939">21939</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0647e7717e43d080e02aa762eedd33f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0647e7717e43d080e02aa762eedd33f7">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a5f2aaec3b681d0a72f7d6e90b70cdcd1">JSON_HEDLEY_RETURNS_NON_NULL</a> T* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::create </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper for exception-safe object creation </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19596">19596</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab4b684342f67317a21b2d9e33ec8feb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b684342f67317a21b2d9e33ec8feb0">&#9670;&nbsp;</a></span>data() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23420">23420</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2430d63f0ffd335f276c085c33c11b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2430d63f0ffd335f276c085c33c11b17">&#9670;&nbsp;</a></span>data() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23425">23425</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac8aaf6afe755ea6c586ab9920389d6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8aaf6afe755ea6c586ab9920389d6bf">&#9670;&nbsp;</a></span>data() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08ad05755736ab9e3416f0556bb47a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ad05755736ab9e3416f0556bb47a6a">&#9670;&nbsp;</a></span>data() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::data </td>
          <td>(</td>
          <td class="paramtype">data &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a416abf41e6c61061dd2be762a88cceb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416abf41e6c61061dd2be762a88cceb8">&#9670;&nbsp;</a></span>data() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::data </td>
          <td>(</td>
          <td class="paramtype">const data &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5699c685383c0e4c824a084cb36e99ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5699c685383c0e4c824a084cb36e99ba">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19772">19772</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a699ef418df577e75f28dfce6b04d6c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699ef418df577e75f28dfce6b04d6c2f">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a diff as a JSON patch </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/diff/">https://json.nlohmann.me/api/basic_json/diff/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24205">24205</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a85df48caed9e341bb14d98ab88891d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85df48caed9e341bb14d98ab88891d1e">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ensure_ascii</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a>&#160;</td>
          <td class="paramname"><em>error_handler</em> = <code>error_handler_t::strict</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialization </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/dump/">https://json.nlohmann.me/api/basic_json/dump/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20488">20488</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac366495e80b2f51a09f07471006cde28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac366495e80b2f51a09f07471006cde28">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>, bool&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object if key does not exist </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/emplace/">https://json.nlohmann.me/api/basic_json/emplace/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22455">22455</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac5f0a15957842b188826aea98a9cfd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f0a15957842b188826aea98a9cfd3d">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/emplace_back/">https://json.nlohmann.me/api/basic_json/emplace_back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22430">22430</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7d0fef086b1b72372113db6ce7446189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0fef086b1b72372113db6ce7446189">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element given an iterator </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21646">21646</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a437b81c6e968a4192a22bc0de6c4df80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437b81c6e968a4192a22bc0de6c4df80">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove elements given an iterator range </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21716">21716</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a05da3b93f2d4a7164589abffaa9acb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05da3b93f2d4a7164589abffaa9acb33">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON object given a key </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21821">21821</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5f763336e84232f38e2d80e142f9820e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f763336e84232f38e2d80e142f9820e">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON object given a key </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21832">21832</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac2c58b5f34c2ff56e27630214f5a9df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c58b5f34c2ff56e27630214f5a9df4">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON array given an index </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21839">21839</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a9737aa07030fa0c9e2909d2c5c03f460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9737aa07030fa0c9e2909d2c5c03f460">&#9670;&nbsp;</a></span>erase_internal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename KeyType , detail::enable_if_t&lt; detail::has_erase_with_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::erase_internal </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21787">21787</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a9737aa07030fa0c9e2909d2c5c03f460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9737aa07030fa0c9e2909d2c5c03f460">&#9670;&nbsp;</a></span>erase_internal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename KeyType , detail::enable_if_t&lt; !detail::has_erase_with_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::erase_internal </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21800">21800</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a727e3cfb5a874314d8deb12cb53a8105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727e3cfb5a874314d8deb12cb53a8105">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21869">21869</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7bf93ae61eb63a9e543cafb3f723900c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf93ae61eb63a9e543cafb3f723900c">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21883">21883</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a89dd769ce700326266883ba96a98a8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dd769ce700326266883ba96a98a8f2">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21899">21899</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="afe1bb257797042aef7142c91f35390d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1bb257797042aef7142c91f35390d8">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21915">21915</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a59327f708c0555e2928487bcddf71293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59327f708c0555e2928487bcddf71293">&#9670;&nbsp;</a></span>from_bjdata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_bjdata </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BJData format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bjdata/">https://json.nlohmann.me/api/basic_json/from_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23753">23753</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="accf7ae6f9b2fee171484c5ef54f08d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf7ae6f9b2fee171484c5ef54f08d1e">&#9670;&nbsp;</a></span>from_bjdata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_bjdata </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BJData format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bjdata/">https://json.nlohmann.me/api/basic_json/from_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23768">23768</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4b0dfca88b11ea59a2568707767622d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0dfca88b11ea59a2568707767622d8">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bson/">https://json.nlohmann.me/api/basic_json/from_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23783">23783</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2513159e8df9a81bf03ed34e1147b42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2513159e8df9a81bf03ed34e1147b42e">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bson/">https://json.nlohmann.me/api/basic_json/from_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23798">23798</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7e33baaab9ab497f0fe6b797134c9524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e33baaab9ab497f0fe6b797134c9524">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23812">23812</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aed9761fba9571455a96309f7ba647757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9761fba9571455a96309f7ba647757">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23821">23821</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5bc3c67eaf6e9b22c8b446f9695249e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc3c67eaf6e9b22c8b446f9695249e9">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in CBOR format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_cbor/">https://json.nlohmann.me/api/basic_json/from_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23585">23585</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a08ab03513b96f5a864bf623aeb70f122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ab03513b96f5a864bf623aeb70f122">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in CBOR format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_cbor/">https://json.nlohmann.me/api/basic_json/from_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23601">23601</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a89a8b31922ebb7a637e723ac7873fa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a8b31922ebb7a637e723ac7873fa4a">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23616">23616</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a8680ff0784c185b6898839a98de88486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8680ff0784c185b6898839a98de88486">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23627">23627</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab0c025488572f913ca5529a2ef62d066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c025488572f913ca5529a2ef62d066">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in MessagePack format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_msgpack/">https://json.nlohmann.me/api/basic_json/from_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23644">23644</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af7d84b161b2d93f9b2b3ac8d68afeb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d84b161b2d93f9b2b3ac8d68afeb96">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in MessagePack format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_msgpack/">https://json.nlohmann.me/api/basic_json/from_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23659">23659</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2a721efc291300b45ac410ab75b8478b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a721efc291300b45ac410ab75b8478b">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23673">23673</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae8c5fdb783d4f97a9062ab41809ec0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c5fdb783d4f97a9062ab41809ec0c6">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23682">23682</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4588941095d03624ada4f0023d93944a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4588941095d03624ada4f0023d93944a">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in UBJSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_ubjson/">https://json.nlohmann.me/api/basic_json/from_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23698">23698</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5dd7470a3be83b27cf162c0261e6b63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd7470a3be83b27cf162c0261e6b63d">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in UBJSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_ubjson/">https://json.nlohmann.me/api/basic_json/from_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23713">23713</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa375318d8ef6052fd4d606d596d9c424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa375318d8ef6052fd4d606d596d9c424">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23727">23727</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad915ce03b8ec612764bb67d09e658a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad915ce03b8ec612764bb67d09e658a0d">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23736">23736</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a162089e94f24182ba3e4484be63c0c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162089e94f24182ba3e4484be63c0c1a">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/front/">https://json.nlohmann.me/api/basic_json/front/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21618">21618</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="afa157d688b97ca85fbcdcb19b769f458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa157d688b97ca85fbcdcb19b769f458">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a>&amp;&gt;().template <a class="el" href="classbasic__json.html#a2fda70d85381ed122d055de8ff66da3c">get_impl</a>&lt;ValueType&gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt;4&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a (pointer) value (explicit) </p>
<p>Performs explicit type conversion between the JSON value and a compatible value if required.</p>
<ul>
<li>If the requested type is a pointer to the internally stored JSON value that pointer is returned. No copies are made.</li>
<li>If the requested type is the current <a class="el" href="classbasic__json.html">basic_json</a>, or a different <a class="el" href="classbasic__json.html">basic_json</a> convertible from the current <a class="el" href="classbasic__json.html">basic_json</a>.</li>
<li>Otherwise the value is converted by calling the <a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueTypeCV</td><td>the provided value type </td></tr>
    <tr><td class="paramname">ValueType</td><td>the returned value type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>if necessary</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">what</td><td><a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method throws if conversion is required</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20960">20960</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac0ed0f6ce2d46a800e930fb7525c6611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ed0f6ce2d46a800e930fb7525c6611">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;<a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a>&amp;&gt;().template <a class="el" href="classbasic__json.html#a8d6d588e99e9f5eeaf3da5155cc57418">get_ptr</a>&lt;PointerType&gt;())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (explicit) </p>
<p>Explicit pointer access to the internally stored JSON value. No copies are made.</p>
<dl class="section warning"><dt>Warning</dt><dd>The pointer becomes invalid if the underlying JSON object changes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointerType</td><td>pointer type; must be a pointer to <a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a>, <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a>, <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>, <a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a>, <a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a>, <a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a>, or <a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the internally stored JSON value if the requested pointer type <em>PointerType</em> fits to the JSON value; <code>nullptr</code> otherwise</dd></dl>
<p>Constant.</p>
<p>{The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a <code>nullptr</code> is returned if the value and the requested pointer type does not match.,get__PointerType}</p>
<dl class="section see"><dt>See also</dt><dd>see <a class="el" href="classbasic__json.html#a8d6d588e99e9f5eeaf3da5155cc57418">get_ptr()</a> for explicit pointer-member access</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21001">21001</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4bceecf563151eb58af179416d8e6299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bceecf563151eb58af179416d8e6299">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the allocator associated with the container </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_allocator/">https://json.nlohmann.me/api/basic_json/get_allocator/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19456">19456</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac55de1b3601085c32e4a1dc32ef6d32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55de1b3601085c32e4a1dc32ef6d32d">&#9670;&nbsp;</a></span>get_binary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a>&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a binary value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_binary/">https://json.nlohmann.me/api/basic_json/get_binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21120">21120</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4ab13e0430cfea76c05ccd062aa528ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab13e0430cfea76c05ccd062aa528ec">&#9670;&nbsp;</a></span>get_binary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a>&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a binary value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_binary/">https://json.nlohmann.me/api/basic_json/get_binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21132">21132</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2fda70d85381ed122d055de8ff66da3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fda70d85381ed122d055de8ff66da3c">&#9670;&nbsp;</a></span>get_impl() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a boolean (explicit) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20621">20621</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa2a895b06bd5de2d9a059083a9a3a582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a895b06bd5de2d9a059083a9a3a582">&#9670;&nbsp;</a></span>get_impl() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , detail::enable_if_t&lt; detail::is_default_constructible&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 0 &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (explicit) </p>
<p>Explicit type conversion between the JSON value and a compatible value which is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a> and <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible">DefaultConstructible</a>. The value is converted by calling the <a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method.</p>
<p>The function is equivalent to executing </p><div class="fragment"><div class="line">ValueType ret;</div><div class="line"><a class="code" href="namespaceanonymous__namespace_02json_8hpp_03.html#a98c92105bf85ea326511a759747d3a0a">JSONSerializer&lt;ValueType&gt;::from_json</a>(*<span class="keyword">this</span>, ret);</div><div class="line"><span class="keywordflow">return</span> ret;</div></div><!-- fragment --><p>This overloads is chosen if:</p><ul>
<li><em>ValueType</em> is not <a class="el" href="classbasic__json.html">basic_json</a>,</li>
<li><a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> has a <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method of the form <code>void from_json(const basic_json&amp;, ValueType&amp;)</code>, and</li>
<li><a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> does not have a <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method of the form <code>ValueType from_json(const basic_json&amp;)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the returned value type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to <em>ValueType</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">what</td><td><a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method throws</td></tr>
  </table>
  </dd>
</dl>
<p>{The example below shows several conversions from JSON values to other types. There a few things to note: (1) Floating-point numbers can be converted to integers\, (2) A JSON array can be converted to a standard <code>std::vector&lt;short&gt;</code>\, (3) A JSON object can be converted to C++ associative containers such as <code>std::unordered_map&lt;std::string\, json&gt;</code>.,get__ValueType_const}</p>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20822">20822</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6f4ced744fab1a861ec51e82928ec249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4ced744fab1a861ec51e82928ec249">&#9670;&nbsp;</a></span>get_impl() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , detail::enable_if_t&lt; detail::has_non_default_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (explicit); special case </p>
<p>Explicit type conversion between the JSON value and a compatible value which is <b>not</b> <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a> and <b>not</b> <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible">DefaultConstructible</a>. The value is converted by calling the <a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method.</p>
<p>The function is equivalent to executing </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> <a class="code" href="namespaceanonymous__namespace_02json_8hpp_03.html#a98c92105bf85ea326511a759747d3a0a">JSONSerializer&lt;ValueType&gt;::from_json</a>(*<span class="keyword">this</span>);</div></div><!-- fragment --><p>This overloads is chosen if:</p><ul>
<li><em>ValueType</em> is not <a class="el" href="classbasic__json.html">basic_json</a> and</li>
<li><a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> has a <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method of the form <code>ValueType from_json(const basic_json&amp;)</code></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> has both overloads of <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code>, this one is chosen.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the returned value type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to <em>ValueType</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">what</td><td><a class="el" href="classbasic__json.html#ab75fd791f0b8fca724e5ed70b4956414">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method throws</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20864">20864</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a76f1255b2138773aa57bf2e22c71a315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f1255b2138773aa57bf2e22c71a315">&#9670;&nbsp;</a></span>get_impl() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BasicJsonType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads converts the current <a class="el" href="classbasic__json.html">basic_json</a> in a different <a class="el" href="classbasic__json.html">basic_json</a> type</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classbasic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this, converted into <em>BasicJsonType</em> </dd></dl>
<p>Depending on the implementation of the called <code><a class="el" href="namespacedetail.html#a6b60b3f3a22e35323af3ecbb1d7e2464">from_json()</a></code> method.</p>
<dl class="section since"><dt>Since</dt><dd>version 3.2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20889">20889</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2632e75860da5fd88f079de332a77059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2632e75860da5fd88f079de332a77059">&#9670;&nbsp;</a></span>get_impl() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; std::is_same&lt; BasicJsonType, basic_json_t &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classbasic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<p>Constant.</p>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20912">20912</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5900ef7d593fd56b0a65cd36c6cea727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5900ef7d593fd56b0a65cd36c6cea727">&#9670;&nbsp;</a></span>get_impl() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , detail::enable_if_t&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a>&amp;&gt;().template <a class="el" href="classbasic__json.html#a8d6d588e99e9f5eeaf3da5155cc57418">get_ptr</a>&lt;PointerType&gt;())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (explicit) </p>
<p>get a pointer value (explicit) Explicit pointer access to the internally stored JSON value. No copies are made.</p>
<dl class="section warning"><dt>Warning</dt><dd>The pointer becomes invalid if the underlying JSON object changes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointerType</td><td>pointer type; must be a pointer to <a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a>, <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a>, <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>, <a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a>, <a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a>, <a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a>, or <a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the internally stored JSON value if the requested pointer type <em>PointerType</em> fits to the JSON value; <code>nullptr</code> otherwise</dd></dl>
<p>Constant.</p>
<p>{The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a <code>nullptr</code> is returned if the value and the requested pointer type does not match.,get__PointerType}</p>
<dl class="section see"><dt>See also</dt><dd>see <a class="el" href="classbasic__json.html#a8d6d588e99e9f5eeaf3da5155cc57418">get_ptr()</a> for explicit pointer-member access</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20925">20925</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="acb17a8039a7027e1a51a03952cf1bd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb17a8039a7027e1a51a03952cf1bd3d">&#9670;&nbsp;</a></span>get_impl() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="verification___hits_charge_time_8_c.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt; {}&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f697c50a38725496e42a802fa66bb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f697c50a38725496e42a802fa66bb4e">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (object) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20632">20632</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a62a08a020217904ff6ab57a6b038a53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a08a020217904ff6ab57a6b038a53f">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (object) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20638">20638</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a9296e26efdc92aef5abd921d0c60f06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9296e26efdc92aef5abd921d0c60f06e">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (array) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20644">20644</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af05cb55fe32eacfada85a9e0d15efd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05cb55fe32eacfada85a9e0d15efd90">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (array) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20650">20650</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae0a7ea5ec94c08d22a7a1005c9ba562b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a7ea5ec94c08d22a7a1005c9ba562b">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (string) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20656">20656</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a650606981b67fc120771fb34c6b0f474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650606981b67fc120771fb34c6b0f474">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (string) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20662">20662</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aecece12aa58729cc5fe4cf7f248a5b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecece12aa58729cc5fe4cf7f248a5b9e">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (boolean) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20668">20668</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac8289f33035c6ae9bdf3d04ffcd2fcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8289f33035c6ae9bdf3d04ffcd2fcf8">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (boolean) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20674">20674</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5a1d3f85882b53f0dea8b83e11d18af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1d3f85882b53f0dea8b83e11d18af5">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (integer number) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20680">20680</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a77d69984f4830a270cde1f49684035fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d69984f4830a270cde1f49684035fc">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (integer number) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20686">20686</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a99ed866b63af3b306fc2ef938f0acd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ed866b63af3b306fc2ef938f0acd06">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (unsigned number) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20692">20692</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a1ba5c2afc523f10792f36e3c2b16de25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba5c2afc523f10792f36e3c2b16de25">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (unsigned number) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20698">20698</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a843a72226992ad9cbe5d131249b5772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843a72226992ad9cbe5d131249b5772d">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (floating-point number) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20704">20704</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a812bf5a6b4ff44ebef6542ed150a2244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812bf5a6b4ff44ebef6542ed150a2244">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (floating-point number) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20710">20710</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af366aaa5f0ba4591a334503219a32d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af366aaa5f0ba4591a334503219a32d4a">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (binary) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20716">20716</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0065d89c2ba863b8a849e89389f6b947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0065d89c2ba863b8a849e89389f6b947">&#9670;&nbsp;</a></span>get_impl_ptr() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_impl_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer to the value (binary) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20722">20722</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a8d6d588e99e9f5eeaf3da5155cc57418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6d588e99e9f5eeaf3da5155cc57418">&#9670;&nbsp;</a></span>get_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;<a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a>&amp;&gt;().<a class="el" href="classbasic__json.html#a0f697c50a38725496e42a802fa66bb4e">get_impl_ptr</a>(std::declval&lt;PointerType&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ptr/">https://json.nlohmann.me/api/basic_json/get_ptr/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20761">20761</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a9c6047ca56f3416ff0bcab2cc6908a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6047ca56f3416ff0bcab2cc6908a51">&#9670;&nbsp;</a></span>get_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const <a class="el" href="classbasic__json.html#aeb9caf9b95ef9e29b440dd1f0c822f74">basic_json_t</a>&amp;&gt;().<a class="el" href="classbasic__json.html#a0f697c50a38725496e42a802fa66bb4e">get_impl_ptr</a>(std::declval&lt;PointerType&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ptr/">https://json.nlohmann.me/api/basic_json/get_ptr/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20772">20772</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3697078e748abc4a99c23e36e321b439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3697078e748abc4a99c23e36e321b439">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ref/">https://json.nlohmann.me/api/basic_json/get_ref/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21050">21050</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a39c5dbafcc6eef79143c251096827549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c5dbafcc6eef79143c251096827549">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ref/">https://json.nlohmann.me/api/basic_json/get_ref/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21061">21061</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3fb599679fd8e475a5c82a7098d2f693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb599679fd8e475a5c82a7098d2f693">&#9670;&nbsp;</a></span>get_ref_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename ThisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ReferenceType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_ref_impl </td>
          <td>(</td>
          <td class="paramtype">ThisType &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to implement <a class="el" href="classbasic__json.html#a3697078e748abc4a99c23e36e321b439" title="get a reference value (implicit) ">get_ref()</a> </p>
<p>This function helps to implement <a class="el" href="classbasic__json.html#a3697078e748abc4a99c23e36e321b439" title="get a reference value (implicit) ">get_ref()</a> without code duplication for const and non-const overloads</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ThisType</td><td>will be deduced as <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a></code> or <code>const <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann ">basic_json</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">type_error.303</td><td>if ReferenceType does not match underlying value type of the current JSON </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20739">20739</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae0c5290f8d96616959270719f6507b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c5290f8d96616959270719f6507b8a">&#9670;&nbsp;</a></span>get_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , detail::enable_if_t&lt; !detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (explicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_to/">https://json.nlohmann.me/api/basic_json/get_to/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21014">21014</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a81b5d8cbbde2eb425b55690024b1a5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b5d8cbbde2eb425b55690024b1a5a1">&#9670;&nbsp;</a></span>get_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , detail::enable_if_t&lt; detail::is_basic_json&lt; ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21027">21027</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6779b8151c44de5f7ca9208a04e0f127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6779b8151c44de5f7ca9208a04e0f127">&#9670;&nbsp;</a></span>get_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename Array  = T (&amp;)[N], detail::enable_if_t&lt; detail::has_from_json&lt; basic_json_t, Array &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21038">21038</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7f3817060c2bec896a99cb2c236b9c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3817060c2bec896a99cb2c236b9c27">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22506">22506</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae5da62116a40a0f86e87f11fdd54e9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5da62116a40a0f86e87f11fdd54e9f0">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22526">22526</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a47b623200562da188886a385c716d101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b623200562da188886a385c716d101">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts copies of element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22533">22533</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a68e1707248a00a2608a304da5ae5c911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e1707248a00a2608a304da5ae5c911">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts range of elements into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22553">22553</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="abdfee6a3db80431a24c68bfaf038c47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfee6a3db80431a24c68bfaf038c47d">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts elements from initializer list into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22584">22584</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aaf55c485c75ddd7bd5f9791e59d3aec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf55c485c75ddd7bd5f9791e59d3aec7">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts range of elements into object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22604">22604</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af8c5ca19d22a32054452470669c43bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c5ca19d22a32054452470669c43bb9">&#9670;&nbsp;</a></span>insert_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::insert_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for insertion of an iterator </p><dl class="section note"><dt>Note</dt><dd>: This uses std::distance to support GCC 4.8, see <a href="https://github.com/nlohmann/json/pull/1257">https://github.com/nlohmann/json/pull/1257</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22487">22487</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a184ba4a6b47e6da3703af19349bd776f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184ba4a6b47e6da3703af19349bd776f">&#9670;&nbsp;</a></span>is_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_array/">https://json.nlohmann.me/api/basic_json/is_array/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20580">20580</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="abbdd993df08641faa3e24b5d2151e8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdd993df08641faa3e24b5d2151e8f8">&#9670;&nbsp;</a></span>is_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a binary array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_binary/">https://json.nlohmann.me/api/basic_json/is_binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20594">20594</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="acfe2e3c359b545f8edbb72f6bd78718c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2e3c359b545f8edbb72f6bd78718c">&#9670;&nbsp;</a></span>is_boolean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_boolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a boolean </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_boolean/">https://json.nlohmann.me/api/basic_json/is_boolean/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20538">20538</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a39e4946a414cc978b88939ed1b343d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e4946a414cc978b88939ed1b343d46">&#9670;&nbsp;</a></span>is_discarded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_discarded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is discarded </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_discarded/">https://json.nlohmann.me/api/basic_json/is_discarded/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20601">20601</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad8789d0a365d5afaab61e7492908d8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8789d0a365d5afaab61e7492908d8b2">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is null </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_null/">https://json.nlohmann.me/api/basic_json/is_null/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20531">20531</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aacf244be5088fb183f4ba21a66af9631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf244be5088fb183f4ba21a66af9631">&#9670;&nbsp;</a></span>is_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number/">https://json.nlohmann.me/api/basic_json/is_number/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20545">20545</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a8d5bb82dfc8cceae1753b52a588eef92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5bb82dfc8cceae1753b52a588eef92">&#9670;&nbsp;</a></span>is_number_float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_number_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a floating-point number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_float/">https://json.nlohmann.me/api/basic_json/is_number_float/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20566">20566</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2330e35cda16540058fef090abc709bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2330e35cda16540058fef090abc709bf">&#9670;&nbsp;</a></span>is_number_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_number_integer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an integer number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_integer/">https://json.nlohmann.me/api/basic_json/is_number_integer/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20552">20552</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4de72635745144ee519157d23fe7189a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de72635745144ee519157d23fe7189a">&#9670;&nbsp;</a></span>is_number_unsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_number_unsigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an unsigned integer number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_unsigned/">https://json.nlohmann.me/api/basic_json/is_number_unsigned/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20559">20559</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af355a2b131068acf3d623eb6d80a711c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af355a2b131068acf3d623eb6d80a711c">&#9670;&nbsp;</a></span>is_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_object/">https://json.nlohmann.me/api/basic_json/is_object/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20573">20573</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad650dd5a7e019b970abce3d8864b5654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad650dd5a7e019b970abce3d8864b5654">&#9670;&nbsp;</a></span>is_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether type is primitive </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_primitive/">https://json.nlohmann.me/api/basic_json/is_primitive/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20517">20517</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a007ecebde9a7d40714e300ce0ff52908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007ecebde9a7d40714e300ce0ff52908">&#9670;&nbsp;</a></span>is_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_string/">https://json.nlohmann.me/api/basic_json/is_string/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20587">20587</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2d3a5f8761bc6f163f4119bddaf7b092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3a5f8761bc6f163f4119bddaf7b092">&#9670;&nbsp;</a></span>is_structured()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::is_structured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether type is structured </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_structured/">https://json.nlohmann.me/api/basic_json/is_structured/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20524">20524</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3b67977cfd161b73161fa9341f8a4158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b67977cfd161b73161fa9341f8a4158">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/front/">https://json.nlohmann.me/api/basic_json/front/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21592">21592</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af9ef76e450ec1bf467c72535becc0be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ef76e450ec1bf467c72535becc0be6">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23849">23849</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a174114f78e24693f61dae1840af50979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174114f78e24693f61dae1840af50979">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23863">23863</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2c01c57845336ed472ccc68be13c364c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c01c57845336ed472ccc68be13c364c">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23877">23877</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ade7d5a2a718ecaf2749c23e619897b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7d5a2a718ecaf2749c23e619897b75">&#9670;&nbsp;</a></span>json_value() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor (for null values) </p>

</div>
</div>
<a id="a2d3c2791c6cac612eb49f44d8e83bb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3c2791c6cac612eb49f44d8e83bb75">&#9670;&nbsp;</a></span>json_value() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for booleans </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19663">19663</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3f8e46eb2120a8f7c63c8d9e62a5b105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8e46eb2120a8f7c63c8d9e62a5b105">&#9670;&nbsp;</a></span>json_value() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for numbers (integer) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19665">19665</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5eff2f2def587632ebb64a2a1d921f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eff2f2def587632ebb64a2a1d921f39">&#9670;&nbsp;</a></span>json_value() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for numbers (unsigned) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19667">19667</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6b174d239bcc49866f2f4d2a5ed82a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b174d239bcc49866f2f4d2a5ed82a99">&#9670;&nbsp;</a></span>json_value() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for numbers (floating-point) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19669">19669</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad919ffad986df2c11159792ba4f733f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad919ffad986df2c11159792ba4f733f2">&#9670;&nbsp;</a></span>json_value() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for empty values of a given type </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19671">19671</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a668dcc1acf6c8872d9aea15c9946922f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668dcc1acf6c8872d9aea15c9946922f">&#9670;&nbsp;</a></span>json_value() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for strings </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19743">19743</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a578593b5d6dd782f1296b6a81acb57df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578593b5d6dd782f1296b6a81acb57df">&#9670;&nbsp;</a></span>json_value() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for rvalue strings </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19746">19746</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa97b5eb40b7491b17a4707db9452603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97b5eb40b7491b17a4707db9452603d">&#9670;&nbsp;</a></span>json_value() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for objects </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19749">19749</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a07fda1c2f595a47099c152caf497b715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fda1c2f595a47099c152caf497b715">&#9670;&nbsp;</a></span>json_value() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for rvalue objects </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19752">19752</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a1472b1d7dccf1de47b28185457f7e08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1472b1d7dccf1de47b28185457f7e08c">&#9670;&nbsp;</a></span>json_value() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for arrays </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19755">19755</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4ea2025deef694f8bcf98b52b9c4a1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea2025deef694f8bcf98b52b9c4a1da">&#9670;&nbsp;</a></span>json_value() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for rvalue arrays </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19758">19758</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="afe346424b682748764754e236cd8c89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe346424b682748764754e236cd8c89d">&#9670;&nbsp;</a></span>json_value() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype">const typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for binary arrays </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19761">19761</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a08c04c85a95df9e2fcad67398fff07f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c04c85a95df9e2fcad67398fff07f2">&#9670;&nbsp;</a></span>json_value() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for rvalue binary arrays </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19764">19764</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aeecd9db0d04a7981f6b09bbf67c3ebef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecd9db0d04a7981f6b09bbf67c3ebef">&#9670;&nbsp;</a></span>json_value() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for binary arrays (internal type) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19767">19767</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa47f2e94e50be0fe53a457f382f93a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47f2e94e50be0fe53a457f382f93a31">&#9670;&nbsp;</a></span>json_value() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::json_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for rvalue binary arrays (internal type) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19770">19770</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a8676ac2433fe299b8d420f00a0741395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8676ac2433fe299b8d420f00a0741395">&#9670;&nbsp;</a></span>merge_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::merge_patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>apply_patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies a JSON Merge Patch </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/merge_patch/">https://json.nlohmann.me/api/basic_json/merge_patch/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24347">24347</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7b435c2ed2db99cb1daa78ae3c6c4580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b435c2ed2db99cb1daa78ae3c6c4580">&#9670;&nbsp;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns version information on the library </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/meta/">https://json.nlohmann.me/api/basic_json/meta/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19464">19464</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a50a0e8dacc0f4aa12162da666595e6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a0e8dacc0f4aa12162da666595e6fd">&#9670;&nbsp;</a></span>object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create an object from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object/">https://json.nlohmann.me/api/basic_json/object/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20228">20228</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a70e1c8fbdb62f3f8bc04e69eef9cc9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e1c8fbdb62f3f8bc04e69eef9cc9cf">&#9670;&nbsp;</a></span>operator value_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type of the JSON value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_value_t/">https://json.nlohmann.me/api/basic_json/operator_value_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20608">20608</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a747e3e19891143442991bbdb33edb917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747e3e19891143442991bbdb33edb917">&#9670;&nbsp;</a></span>operator ValueType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , typename std::enable_if&lt; detail::conjunction&lt; detail::negation&lt; std::is_pointer&lt; ValueType &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, std::nullptr_t &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, detail::json_ref&lt; basic_json &gt;&gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, typename string_t::value_type &gt;&gt;, detail::negation&lt; detail::is_basic_json&lt; ValueType &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt;&gt;&gt;, detail::is_detected_lazy&lt; detail::get_template_function, const basic_json_t &amp;, ValueType &gt; &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#aefed8cf27cadeea45f12c6f3db3ce774">JSON_EXPLICIT</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator ValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (implicit) </p>
<p>Implicit type conversion between the JSON value and a compatible value. The call is realized by calling <a class="el" href="classbasic__json.html#afa157d688b97ca85fbcdcb19b769f458">get() const</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>non-pointer type compatible to the JSON value, for instance <code>int</code> for JSON integer numbers, <code>bool</code> for JSON booleans, or <code>std::vector</code> types for JSON arrays. The character type of <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> as well as an initializer list of this type is excluded to avoid ambiguities as these types implicitly convert to <code>std::string</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to type <em>ValueType</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">type_error.302</td><td>in case passed type <em>ValueType</em> is incompatible to the JSON value type (e.g., the JSON value is of type boolean, but a string is requested); see example below</td></tr>
  </table>
  </dd>
</dl>
<p>Linear in the size of the JSON value.</p>
<p>{The example below shows several conversions from JSON values to other types. There a few things to note: (1) Floating-point numbers can be converted to integers\, (2) A JSON array can be converted to a standard <code>std::vector&lt;short&gt;</code>\, (3) A JSON object can be converted to C++ associative containers such as <code>std::unordered_map&lt;std::string\, json&gt;</code>.,operator__ValueType}</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21112">21112</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac444a656905e3f207ad9fc19275faf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac444a656905e3f207ad9fc19275faf25">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22334">22334</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4475e951f51506808ca6fe7e77eb38ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4475e951f51506808ca6fe7e77eb38ca">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22366">22366</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a996a58d60e4badd9beadfd3e2e7ffdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996a58d60e4badd9beadfd3e2e7ffdc1">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22397">22397</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3af74b651da5642cd8b77a3ecc635331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af74b651da5642cd8b77a3ecc635331">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22421">22421</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab0b20f4ac45a0f6e5ac2a2fb6138c19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b20f4ac45a0f6e5ac2a2fb6138c19f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assignment </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator=/">https://json.nlohmann.me/api/basic_json/operator=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20447">20447</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac8b114795c5e45d242a88d3e2306114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b114795c5e45d242a88d3e2306114c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a>&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a345d693c6d7e58a3e486a4436d60956a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345d693c6d7e58a3e486a4436d60956a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a>&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4f511db82b9d5eba85d5b2b8e1c6dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f511db82b9d5eba85d5b2b8e1c6dbb">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21277">21277</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae369d1565482903c3af75bf99467776b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae369d1565482903c3af75bf99467776b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21323">21323</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a9c5825034534bf9256a33d2dd995c25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5825034534bf9256a33d2dd995c25a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">typename object_t::key_type&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21336">21336</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3d3ea17617e94886f3e86ac921095a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3ea17617e94886f3e86ac921095a13">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21358">21358</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a87cae3810ae0a9c56b17842b06fc405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cae3810ae0a9c56b17842b06fc405e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21374">21374</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab12a4386e6913012ca4dffa0245fdf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12a4386e6913012ca4dffa0245fdf99">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21380">21380</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a06fe1a1c7aa8c193c73aa40b17ee5f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fe1a1c7aa8c193c73aa40b17ee5f68">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21389">21389</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2e11a3f2a234cd296b515173b6a3b986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e11a3f2a234cd296b515173b6a3b986">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21413">21413</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a274307158c76b820701077dd471cc75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274307158c76b820701077dd471cc75b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23843">23843</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6aedef6230f66b1271d71a6f77e7fed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aedef6230f66b1271d71a6f77e7fed3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23857">23857</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac9a6dcbf8716e58f662a86c1bbcff565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a6dcbf8716e58f662a86c1bbcff565">&#9670;&nbsp;</a></span>parser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputAdapterType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::nlohmann::detail::parser&lt;<a class="el" href="classbasic__json.html">basic_json</a>, InputAdapterType&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::parser </td>
          <td>(</td>
          <td class="paramtype">InputAdapterType&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a20a6b9b232b9f47ce057fe5cc5bbf511">detail::parser_callback_t</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &gt;&#160;</td>
          <td class="paramname"><em>cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19346">19346</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a145a004c0a2fa5be84b260ecc98ab5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145a004c0a2fa5be84b260ecc98ab5d9">&#9670;&nbsp;</a></span>patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>json_patch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies a JSON patch to a copy of the current object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/patch/">https://json.nlohmann.me/api/basic_json/patch/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24195">24195</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aca01ca3a9bc310e5c5d067a39dca6933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca01ca3a9bc310e5c5d067a39dca6933">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22342">22342</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af17fe93acad9b0b991600225dabd42be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17fe93acad9b0b991600225dabd42be">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22374">22374</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4fcacc90f17b156f0b6c8e0430624853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcacc90f17b156f0b6c8e0430624853">&#9670;&nbsp;</a></span>push_back() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22405">22405</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="addedd5e53fa6eff6cd621f1615741c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addedd5e53fa6eff6cd621f1615741c3d">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> bool static SAX bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="_w_c_sim_l_i_gen_8cc.html#ab701e3ac61a85b337ec5c1abaad6742d">input_format_t::json</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23304">23304</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a94cbf1844fef86e9301282ad8ca0f822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cbf1844fef86e9301282ad8ca0f822">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , class SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="_w_c_sim_l_i_gen_8cc.html#ab701e3ac61a85b337ec5c1abaad6742d">input_format_t::json</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate SAX events </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/sax_parse/">https://json.nlohmann.me/api/basic_json/sax_parse/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23319">23319</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad018e709338c810c56eaad606186a77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad018e709338c810c56eaad606186a77e">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="_w_c_sim_l_i_gen_8cc.html#ab701e3ac61a85b337ec5c1abaad6742d">input_format_t::json</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate SAX events </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/sax_parse/">https://json.nlohmann.me/api/basic_json/sax_parse/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This function is deprecated since 3.8.0 and will be removed in version 4.0.0 of the library. Please use sax_parse(ptr, ptr + len) instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23338">23338</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a01f3fc8d1028c1bee49974c0b62b2611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f3fc8d1028c1bee49974c0b62b2611">&#9670;&nbsp;</a></span>set_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::set_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>old_capacity</em> = <code>static_cast&lt;std::size_t&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19971">19971</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a960be8bb5f127dd11c33d861622a5fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960be8bb5f127dd11c33d861622a5fa7">&#9670;&nbsp;</a></span>set_parents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::set_parents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19921">19921</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="abd445a8a1ccb0ef0302b00529543a9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd445a8a1ccb0ef0302b00529543a9ba">&#9670;&nbsp;</a></span>set_parents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::set_parents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename iterator::difference_type&#160;</td>
          <td class="paramname"><em>count_set_parents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19958">19958</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2a37aad28d7d89ed2eb04a8a9928552b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a37aad28d7d89ed2eb04a8a9928552b">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22683">22683</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac1e32c91d5e641c25c52486341f5a9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e32c91d5e641c25c52486341f5a9db">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22712">22712</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="abc9ea6dec87e254de172c2bfeaeef7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9ea6dec87e254de172c2bfeaeef7df">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22728">22728</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aeac8816c033c659ef8b43a5f03d5f553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac8816c033c659ef8b43a5f03d5f553">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22744">22744</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3624e1bbc880bd196e3fa4a220554755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3624e1bbc880bd196e3fa4a220554755">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22760">22760</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa987625005046c81e7748dca1e84a0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa987625005046c81e7748dca1e84a0e3">&#9670;&nbsp;</a></span>swap() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22776">22776</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af410354f1c82a34f388e438cc47c31f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af410354f1c82a34f388e438cc47c31f8">&#9670;&nbsp;</a></span>to_bjdata() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23533">23533</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2736658c256401394059599f97139ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2736658c256401394059599f97139ee9">&#9670;&nbsp;</a></span>to_bjdata() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23544">23544</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a1fa9828fcbe4e33c9a036834564f7dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa9828fcbe4e33c9a036834564f7dbd">&#9670;&nbsp;</a></span>to_bjdata() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23552">23552</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae0945ada0a9b5afd776b2d6ea2c048a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0945ada0a9b5afd776b2d6ea2c048a5">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23560">23560</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="afd718b745034da1f4eea4c69f45cebda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd718b745034da1f4eea4c69f45cebda">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23569">23569</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a71794547dde3dd67e444aa45131ca861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71794547dde3dd67e444aa45131ca861">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23576">23576</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a9bea2fdeaff0956562cafd89fdba9139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bea2fdeaff0956562cafd89fdba9139">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23460">23460</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a706ccab0e47bd75cd36911db84451cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706ccab0e47bd75cd36911db84451cd1">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23469">23469</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af31f5ee23264fb21bd31e16bc27adab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31f5ee23264fb21bd31e16bc27adab2">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23476">23476</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad317526e90c898957af9ce1c8c011caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad317526e90c898957af9ce1c8c011caa">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23483">23483</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af46fdac62559d4c38e623d99ad7064e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46fdac62559d4c38e623d99ad7064e9">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23492">23492</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a51da13ff4e850d4ad1cf23ce4f3b9e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51da13ff4e850d4ad1cf23ce4f3b9e4a">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23499">23499</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="afa6d27aedd29bed0cd145638f4f32fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6d27aedd29bed0cd145638f4f32fdc">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23506">23506</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ada3d71f1dcfea24465d364b815d11445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3d71f1dcfea24465d364b815d11445">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23517">23517</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab8b6c6cc3ba1b49af628fe0ec8c73b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b6c6cc3ba1b49af628fe0ec8c73b77">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23525">23525</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac5e52dbb3cb4e9fcabd1b88c37985aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e52dbb3cb4e9fcabd1b88c37985aef">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::<a class="el" href="classstd_1_1conditional_1_1type.html">type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type of the JSON value (explicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/type/">https://json.nlohmann.me/api/basic_json/type/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20510">20510</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="afb684c446c48759336dc227f16b7d3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb684c446c48759336dc227f16b7d3f4">&#9670;&nbsp;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a5f2aaec3b681d0a72f7d6e90b70cdcd1">JSON_HEDLEY_RETURNS_NON_NULL</a> const char* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type as string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/type_name/">https://json.nlohmann.me/api/basic_json/type_name/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23380">23380</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3819f393e82396782ccc22785575b01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3819f393e82396782ccc22785575b01d">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge_objects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a JSON object from another object, overwriting existing keys </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/update/">https://json.nlohmann.me/api/basic_json/update/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22629">22629</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4ea2b8cef5e4aba5b92d14e6ebe25936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea2b8cef5e4aba5b92d14e6ebe25936">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge_objects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a JSON object from another object, overwriting existing keys </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/update/">https://json.nlohmann.me/api/basic_json/update/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22636">22636</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a80c2436388fd16a1529ce9afce8229ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c2436388fd16a1529ce9afce8229ef">&#9670;&nbsp;</a></span>value() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , detail::enable_if_t&lt; !detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21443">21443</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a56244e0ed0943ad62faf61b06e7ba139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56244e0ed0943ad62faf61b06e7ba139">&#9670;&nbsp;</a></span>value() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; !detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21468">21468</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="acbe572bbfbd4687a7a9167465e4d41f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe572bbfbd4687a7a9167465e4d41f2">&#9670;&nbsp;</a></span>value() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class KeyType , detail::enable_if_t&lt; detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;is_comparable_with_object_key&lt; KeyType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21494">21494</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a694398741710ce1c22797ad47109898b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694398741710ce1c22797ad47109898b">&#9670;&nbsp;</a></span>value() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class KeyType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;is_comparable_with_object_key&lt; KeyType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21521">21521</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac63045992eb552c11f77fefddd801591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63045992eb552c11f77fefddd801591">&#9670;&nbsp;</a></span>value() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , detail::enable_if_t&lt; detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21544">21544</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a1ab7b5edf8e5831195940f8d377a6ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab7b5edf8e5831195940f8d377a6ee3">&#9670;&nbsp;</a></span>value() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21569">21569</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aa226ed5103dfd10e27e562d35a3a106b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa226ed5103dfd10e27e562d35a3a106b">&#9670;&nbsp;</a></span>::nlohmann::detail::binary_reader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename InputType , typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::binary_reader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19330">19330</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a69d491bbda88ade6d3c7a2b11309e8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d491bbda88ade6d3c7a2b11309e8bf">&#9670;&nbsp;</a></span>::nlohmann::detail::binary_writer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename CharType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::binary_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19328">19328</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="abdcb15d025676b4d3db0f32a50f4393f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcb15d025676b4d3db0f32a50f4393f">&#9670;&nbsp;</a></span>::nlohmann::detail::exception</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::exception</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19335">19335</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a842e5c7ca096025c18b11e715d3401f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842e5c7ca096025c18b11e715d3401f4">&#9670;&nbsp;</a></span>::nlohmann::detail::iter_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::iter_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19326">19326</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a95574da8d12905ea99dc348934c837da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95574da8d12905ea99dc348934c837da">&#9670;&nbsp;</a></span>::nlohmann::detail::json_sax_dom_callback_parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::json_sax_dom_callback_parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19334">19334</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a47aabb1eceae32e8a6e8e7f0ff34be60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47aabb1eceae32e8a6e8e7f0ff34be60">&#9670;&nbsp;</a></span>::nlohmann::detail::json_sax_dom_parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::json_sax_dom_parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19332">19332</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac8f3125911eb018ef4ab00d879487baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f3125911eb018ef4ab00d879487baf">&#9670;&nbsp;</a></span>::nlohmann::detail::parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19323">19323</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a43f901b14cf3f7135269b0c75c9ac233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f901b14cf3f7135269b0c75c9ac233">&#9670;&nbsp;</a></span>::nlohmann::json_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::json_pointer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19318">19318</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6275ed57bae6866cdf5db5370a7ad47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6275ed57bae6866cdf5db5370a7ad47c">&#9670;&nbsp;</a></span>detail::external_constructor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;detail::value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structdetail_1_1external__constructor.html">detail::external_constructor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19315">19315</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a60ca396028b8d9714c6e10efbf475af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ca396028b8d9714c6e10efbf475af6">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_gtgt/">https://json.nlohmann.me/api/basic_json/operator_gtgt/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This stream operator is deprecated since 3.0.0 and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classbasic__json.html#aaf363408931d76472ded14017e59c9e8" title="deserialize from stream ">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23358">23358</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aaf363408931d76472ded14017e59c9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf363408931d76472ded14017e59c9e8">&#9670;&nbsp;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_gtgt/">https://json.nlohmann.me/api/basic_json/operator_gtgt/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23365">23365</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aee0ae36cbfb0336832ebc0374c3c7679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0ae36cbfb0336832ebc0374c3c7679">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22700">22700</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa82137724f80ebaa92ec6544eb5e544a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82137724f80ebaa92ec6544eb5e544a">&#9670;&nbsp;</a></span>__pad0__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::__pad0__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19343">19343</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="acb1d2f61621d0cb05507f5a48d25fb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1d2f61621d0cb05507f5a48d25fb26">&#9670;&nbsp;</a></span>__pad1__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::__pad1__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19375">19375</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4c0831d0e3207eb079fb274eb0d3dcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0831d0e3207eb079fb274eb0d3dcc5">&#9670;&nbsp;</a></span>__pad2__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::__pad2__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19644">19644</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7dd56e6dab5328365a3c9b9d15f98e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd56e6dab5328365a3c9b9d15f98e1b">&#9670;&nbsp;</a></span>__pad3__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::__pad3__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22878">22878</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a27054edf6738852b42e0218fe4337e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27054edf6738852b42e0218fe4337e1c">&#9670;&nbsp;</a></span>__pad4__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::__pad4__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23415">23415</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5299b166ebd27030235e2314a0cf5882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5299b166ebd27030235e2314a0cf5882">&#9670;&nbsp;</a></span>array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::array</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array (stored with pointer to save storage) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19646">19646</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a8ba94a85b63eab2443e7fab8cb26d150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba94a85b63eab2443e7fab8cb26d150">&#9670;&nbsp;</a></span>binary</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::binary</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>binary (stored with pointer to save storage) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19650">19650</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="afe268377946f15ff7b309b887e8ef8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe268377946f15ff7b309b887e8ef8ac">&#9670;&nbsp;</a></span>boolean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::boolean</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>boolean </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19652">19652</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a54aba2f4314135e3ccf511fb17ca45a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54aba2f4314135e3ccf511fb17ca45a5">&#9670;&nbsp;</a></span>inverse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::inverse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22878">22878</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4f7fd3c3afd2abb77797652506ab6bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7fd3c3afd2abb77797652506ab6bc0">&#9670;&nbsp;</a></span>m_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ab4b684342f67317a21b2d9e33ec8feb0">data</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::m_data = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23443">23443</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="acd0f167153f047a246b51858d7c921b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0f167153f047a246b51858d7c921b8">&#9670;&nbsp;</a></span>m_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ade7d5a2a718ecaf2749c23e619897b75">json_value</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::m_value = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the value of the current element </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23418">23418</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a10dca98c209830ac0cf1019fa99e0031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dca98c209830ac0cf1019fa99e0031">&#9670;&nbsp;</a></span>number_float</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::number_float</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number (floating-point) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19658">19658</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="acda00ee3da4d87072260cf07d1143f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda00ee3da4d87072260cf07d1143f62">&#9670;&nbsp;</a></span>number_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::number_integer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number (integer) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19654">19654</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0a54245650ef57a6d8375592821a5344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a54245650ef57a6d8375592821a5344">&#9670;&nbsp;</a></span>number_unsigned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::number_unsigned</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number (unsigned integer) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19656">19656</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3a549b97cc690cd390145249335d3768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a549b97cc690cd390145249335d3768">&#9670;&nbsp;</a></span>rhs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a2cf645f34610e7f7d6e09ab88a2ab917">JSON_PRIVATE_UNLESS_TESTED</a> <a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::rhs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22878">22878</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a814cc0333d9ecea13eb0554fd35df8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814cc0333d9ecea13eb0554fd35df8ec">&#9670;&nbsp;</a></span>string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, <a class="el" href="class_binary_type.html">BinaryType</a>, CustomBaseClass &gt;::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>string (stored with pointer to save storage) </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19648">19648</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="json_8hpp_source.html">json.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 4 2024 10:20:04 for WCSim by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
